<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="JAVA">
<meta property="og:type" content="website">
<meta property="og:title" content="小猪佩琪">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小猪佩琪">
<meta property="og:description" content="JAVA">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小猪佩琪">
<meta name="twitter:description" content="JAVA">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>小猪佩琪</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小猪佩琪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小猪佩琪的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/异常处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/异常处理/" itemprop="url">异常处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-18T16:31:48+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-异常概述"><a href="#1-异常概述" class="headerlink" title="1.异常概述"></a><em>1.异常概述</em></h3><p>在运行程序时可能出现的一些错误称为异常。</p>
<h3 id="2-异常的分类"><a href="#2-异常的分类" class="headerlink" title="2.异常的分类"></a><em>2.异常的分类</em></h3><p>java类库中的每个包中都定义了异常类，所有这些类都是throwable类的子类。throwable类派生了两个子类，分别是Error和Exception类，其中Error类及其子类用来描述Java运行系统的内部错误以及资源耗尽的错误，这类错误比较严重。Exception类称为非致命性类，可以通过捕捉处理是程序继续执行。Exption根据错误发生的原因分为运行时异常和非运行时异常。</p>
<h4 id="1-系统错误–error"><a href="#1-系统错误–error" class="headerlink" title="1.系统错误–error"></a>1.系统错误–error</h4><p>Error类及其子类用来描述java运行系统中的内部错误，该类定义了常规情况下不希望程序捕获的异常，这些错误发生时，Java虚拟机一般会选择线程终止。</p>
<h4 id="2-异常–exeception"><a href="#2-异常–exeception" class="headerlink" title="2.异常–exeception"></a>2.异常–exeception</h4><h5 id="1-运行时异常"><a href="#1-运行时异常" class="headerlink" title="1.运行时异常"></a>1.运行时异常</h5><p>运行时异常是程序运行过程中产生的异常，它是RuntimeException类及其子类异常，这些异常一般是由程序逻辑错误引起的，所以应该从逻辑角度尽可能避免这类异常的发生。这些异常可通过try…catch语句捕获。</p>
<table>
<thead>
<tr>
<th style="text-align:center">异常类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ClassCastException</td>
<td style="text-align:center">类型转换异常</td>
</tr>
<tr>
<td style="text-align:center">NullPointerException</td>
<td style="text-align:center">空指针异常</td>
</tr>
<tr>
<td style="text-align:center">ArrayIndexOutOfBoundsException</td>
<td style="text-align:center">数组下标越界异常</td>
</tr>
<tr>
<td style="text-align:center">ArithmeticException</td>
<td style="text-align:center">算数异常</td>
</tr>
<tr>
<td style="text-align:center">ArrayStoreException</td>
<td style="text-align:center">数组中包含不兼容的值抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">NumberFormatException</td>
<td style="text-align:center">字符串转换为数字抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">IllegalArgumentException</td>
<td style="text-align:center">非法参数异常</td>
</tr>
<tr>
<td style="text-align:center">FileSystemNotFoundException</td>
<td style="text-align:center">文件系统未找到异常</td>
</tr>
<tr>
<td style="text-align:center">SecurityException</td>
<td style="text-align:center">安全性异常</td>
</tr>
<tr>
<td style="text-align:center">StringIndexOutOfBoundsException</td>
<td style="text-align:center">字符串索引超出范围抛出的异常</td>
</tr>
<tr>
<td style="text-align:center">NegativeArraySizeException</td>
<td style="text-align:center">数组长度为负异常</td>
</tr>
</tbody>
</table>
<h5 id="2-非运行时异常"><a href="#2-非运行时异常" class="headerlink" title="2.非运行时异常"></a>2.非运行时异常</h5><p>非运行时异常是RuntimeException类及其子类以外的异常，从程序语法角度上讲，这类异常是必须进行处理的异常，如果不处理，程序无法编译通过。</p>
<table>
<thead>
<tr>
<th style="text-align:center">异常类</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ClassNotFoundException</td>
<td style="text-align:center">未找到相应类异常</td>
</tr>
<tr>
<td style="text-align:center">SQLException</td>
<td style="text-align:center">操作数据库异常</td>
</tr>
<tr>
<td style="text-align:center">IOException</td>
<td style="text-align:center">输入/输出流异常</td>
</tr>
<tr>
<td style="text-align:center">TimeoutException</td>
<td style="text-align:center">操作超时异常</td>
</tr>
<tr>
<td style="text-align:center">FileNotFoundException</td>
<td style="text-align:center">文件未找到异常</td>
</tr>
</tbody>
</table>
<h3 id="3-捕捉处理异常"><a href="#3-捕捉处理异常" class="headerlink" title="3.捕捉处理异常"></a><em>3.捕捉处理异常</em></h3><h4 id="1-try…catch代码块"><a href="#1-try…catch代码块" class="headerlink" title="1.try…catch代码块"></a>1.try…catch代码块</h4><p>当try代码块中的语句发生异常时，程序就会跳转到catch代码块中执行，执行完catch代码块中的程序代码后，将继续执行catch代码块后的其他代码，而不会执行try代码块发生异常语句后面的代码。</p>
<h4 id="2-finally代码块"><a href="#2-finally代码块" class="headerlink" title="2.finally代码块"></a>2.finally代码块</h4><p>无论程序中有无异常发生，finally代码块中的代码都可以正常执行。</p>
<p>在以下三种情况下，finally块不会被执行：</p>
<p>1.在finally代码块中发生了异常</p>
<p>2.在前面的代码中使用了System.exit()退出程序。</p>
<p>3.程序所在的线程死亡。</p>
<h3 id="4-在方法中抛出异常"><a href="#4-在方法中抛出异常" class="headerlink" title="4.在方法中抛出异常"></a><em>4.在方法中抛出异常</em></h3><h4 id="1-使用throws关键字抛出异常"><a href="#1-使用throws关键字抛出异常" class="headerlink" title="1.使用throws关键字抛出异常"></a>1.使用throws关键字抛出异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型名 方法名(参数表) throws 异常类型名&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子类继承父类，子类重写方法抛出的异常和原父类的相同或其子类。</p>
<h4 id="2-使用throw关键字抛出异常"><a href="#2-使用throw关键字抛出异常" class="headerlink" title="2.使用throw关键字抛出异常"></a>2.使用throw关键字抛出异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new 异常类型名（异常信息）</span><br></pre></td></tr></table></figure>
<p><strong>throws关键字和throw关键字的区别如下：</strong></p>
<p>1）throws用在方法声明后面，表示抛出异常，由方法的调用者处理；而throw用在方法体内，用来制造一个异常，由方法内的语句处理。</p>
<p>2）throws是声明这个方法会抛出这种类型的异常，以便使它的调用者知道要捕获这个异常，而throw是直接抛出一个异常实例。</p>
<p>3）throws表示出现异常的一种可能性，并不一定会发生这些异常；而throw，就一定会产生某种异常。</p>
<h3 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5.自定义异常"></a><em>5.自定义异常</em></h3><p>大体可分成以下几步：</p>
<p>1）创建自定义异常类</p>
<p>2）在方法中通过throw关键字抛出异常对象</p>
<p>3）如果在当前抛出异常的方法中处理异常，可以使用try…catch代码块捕获并处理异常，否则，在方法的声明处通过throws关键字指明要抛给方法调用者的异常，继续下一步操作。</p>
<p>4）在出现异常方法的调用者中捕获并处理异常。</p>
<p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/18/多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/多线程/" itemprop="url">多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-18T08:49:09+08:00">
                2018-11-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-线程的简介"><a href="#1-线程的简介" class="headerlink" title="1.线程的简介"></a><em>1.线程的简介</em></h3><p><strong>并发</strong>：多个活动可以同时进行，这种机制在Java中被称为并发。</p>
<p><strong>线程</strong>：程序在执行过程中，能够执行程序代码的一个执行单元。</p>
<p><strong>多线程</strong>：Java语言提供了并发机制，程序员在程序中执行多个线程，每个线程实现一个功能，并与其它线程并发执行，这种机制被称为多线程。</p>
<p><strong>进程</strong>：Windows操作系统是多任务操作系统，它以进程为单位，一个进程是一个包含有自身地址的程序，每个独立执行的程序都称为进程。比如正在运行的QQ是一个进程。每个进程都可以同时包含多个线程。</p>
<h3 id="2-实现线程的三种方式"><a href="#2-实现线程的三种方式" class="headerlink" title="2.实现线程的三种方式"></a><em>2.实现线程的三种方式</em></h3><h4 id="1-继承Thread类，重写run-方法"><a href="#1-继承Thread类，重写run-方法" class="headerlink" title="1.继承Thread类，重写run()方法"></a>1.继承Thread类，重写run()方法</h4><p>Thread类是java.lang包中的一个类，本质上来说也是实现了Runnable接口的一个实例。它代表一个线程的实例。通过继承Thread类创建并执行一个线程的步骤如下：</p>
<p>(1)创建一个继承自Thred类的子类</p>
<p>(2)重写Thread类的run()方法</p>
<p>(3)创建线程类的一个对象</p>
<p>(4)通过线程类的一个对象调用start方法启动线程</p>
<p>Thread类中常见的两个构造方法如下：</p>
<p>public Thread();</p>
<p>public Thread(String threadName)</p>
<p><strong>Thread类的常用方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">interrupt()</td>
<td style="text-align:center">中断线程</td>
</tr>
<tr>
<td style="text-align:center">join()</td>
<td style="text-align:center">等待该线程终止</td>
</tr>
<tr>
<td style="text-align:center">join(long millis)</td>
<td style="text-align:center">等待该线程终止的时间最长为millis毫秒</td>
</tr>
<tr>
<td style="text-align:center">run()</td>
<td style="text-align:center">如果该对象是使用独立的Runnable运行对象构造的，则调用该Runnable对象的run方法；否则，该方法不执行任何操作并返回</td>
</tr>
<tr>
<td style="text-align:center">setPriority()</td>
<td style="text-align:center">更改线程的优先级</td>
</tr>
<tr>
<td style="text-align:center">sleep(long millis)</td>
<td style="text-align:center">在指定毫秒数内让当前正在执行的线程休眠</td>
</tr>
<tr>
<td style="text-align:center">start()</td>
<td style="text-align:center">是该线程开始执行：java虚拟机调用该线程的run方法</td>
</tr>
<tr>
<td style="text-align:center">yield()</td>
<td style="text-align:center">暂停当前正在执行的线程对象，并执行其他线程</td>
</tr>
</tbody>
</table>
<h4 id="2-实现Runnable接口，并实现接口的run-方法"><a href="#2-实现Runnable接口，并实现接口的run-方法" class="headerlink" title="2.实现Runnable接口，并实现接口的run()方法"></a>2.实现Runnable接口，并实现接口的run()方法</h4><p>通过实现Runnable接口创建并执行一个线程的步骤如下：</p>
<p>(1)自定义类并实现Runnable接口，并实现该接口的run()方法</p>
<p>(2)创建Thread对象，并将实现Runnable接口的对象作为参数实例化该Thread对象。</p>
<p>(3)调用Thread的start()方法。</p>
<p>实现Runnable接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联。Thread勒种有以下两个构造方法：</p>
<p>public Thread(Runnable target)</p>
<p>public Thread(Runnable target,String name)</p>
<h4 id="3-实现Callable接口，重写call-方法"><a href="#3-实现Callable接口，重写call-方法" class="headerlink" title="3.实现Callable接口，重写call()方法"></a>3.实现Callable接口，重写call()方法</h4><p>callable接口实际上是属于Executor框架中的功能类。</p>
<p>callable接口与runnable接口的功能类似，但提供了更加强大的功能：</p>
<p>(1)callable可以在任务结束后提供一个返回值，而runnable无法提供这个功能</p>
<p>(2)callable中的call()方法可以抛出异常，而runnable无法提供这个功能</p>
<p>(3)运行callable可以拿到一个Future对象，Future对象表示异步计算的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CallableAndFuture&#123;</span><br><span class="line">    //创建线程类</span><br><span class="line">    public static class CallableTest implements Callable&lt;String&gt;&#123;</span><br><span class="line">        public String call() throws Exception&#123;</span><br><span class="line">            return &quot;Hello Worlds&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ExecutorService threadPool = Executor.newSingleThreadExecutor();</span><br><span class="line">        //启动线程</span><br><span class="line">        Future&lt;String&gt; future=threadPool.submit(new CallableTest());</span><br><span class="line">        try&#123;</span><br><span class="line">            System.out.println(&quot;waiting thread to finish&quot;);</span><br><span class="line">            System.out.println(future.get());//等待线程结束，并获取返回结果</span><br><span class="line">        &#125;catch(Exeception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a><em>3.线程的生命周期</em></h3><p>五种状态：出生状态，就绪状态，运行状态，暂停状态，死亡状态</p>
<p>出生状态是线程被创建时处于的状态，在用户调用该线程实例的start()方法之前都处于出生状态。</p>
<p>就绪状态：当用户调用start()方法后，线程就处于就绪状态。</p>
<p>运行状态：当线程得到系统资源后就进入运行状态。</p>
<p>暂停状态：当处于运行状态下的线程调用sleep(),wait()方法或者发生阻塞时，会进入暂停状态。当在休眠结束，调用notify()方法，notifyAll()方法或者阻塞解除时，会重新进入就绪状态。</p>
<p>死亡状态：当程序的run()方法执行完毕，或者线程发生错误，异常时，线程进入死亡状态。</p>
<h3 id="4-操作线程的方法"><a href="#4-操作线程的方法" class="headerlink" title="4.操作线程的方法"></a><em>4.操作线程的方法</em></h3><h4 id="1-线程的休眠"><a href="#1-线程的休眠" class="headerlink" title="1.线程的休眠"></a>1.线程的休眠</h4><p>sleep方法的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    Thread.sleep(2000);</span><br><span class="line">&#125;catch(InterruptedException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-线程的加入"><a href="#2-线程的加入" class="headerlink" title="2.线程的加入"></a>2.线程的加入</h4><p>join方法：当某个线程使用join()方法加入另一个线程时，另一个线程会等待该线程执行完毕后再继续执行。</p>
<h4 id="3-线程的中断"><a href="#3-线程的中断" class="headerlink" title="3.线程的中断"></a>3.线程的中断</h4><p>可以使用Thread类中的interrupt()方法使线程离开run()方法，同时结束线程，但程序会抛出InterruptedException异常。</p>
<h3 id="5-线程的优先级"><a href="#5-线程的优先级" class="headerlink" title="5.线程的优先级"></a><em>5.线程的优先级</em></h3><p>线程的优先级可以使用setPriority()方法调整，如果使用该方法设置的优先级不在1~10之内，将产生IllegalArgumentException异常。</p>
<p>线程的优先级只是增加或减少线程优先执行的概率，并不能保证线程一定会优先或延后执行。</p>
<h3 id="6-线程的同步"><a href="#6-线程的同步" class="headerlink" title="6.线程的同步"></a><em>6.线程的同步</em></h3><h4 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h4><p>实质上线程安全问题来源于两个线程同时存取单一对象数据。</p>
<h4 id="2-线程同步机制"><a href="#2-线程同步机制" class="headerlink" title="2.线程同步机制"></a>2.线程同步机制</h4><p>锁：锁的主要作用是为了防止不同线程在同一时间访问同一个代码块。</p>
<p>死锁：就是两个线程运行时都在等待对方的锁，从而造成了程序的停滞。</p>
<h5 id="1-同步块"><a href="#1-同步块" class="headerlink" title="1.同步块"></a>1.同步块</h5><p>同步机制使用synchronized关键字，使用该关键字包含的代码块称为同步块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">synchronized(Object)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="2.同步方法"></a>2.同步方法</h5><p>就是方法面前使用synchronized关键字修饰的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized void f()&#123; &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-lock"><a href="#3-lock" class="headerlink" title="3.lock"></a>3.lock</h5><p>1.lock():以阻塞方式获取锁，即如果获取了锁，立即返回；如果别的线程持有锁，当前线程等待，直到获取锁后返回。</p>
<p>2.tryLock():以非阻塞的方式获取锁。只是尝试性的去获取一下锁，如果获取到锁，立即返回true,否则，立即返回false.</p>
<p>3.tryLock(long timeout,TimeUnit unit):如果获取了锁，立即返回true,否则会等待参数给定的时间单元，在等待的过程中，如果获取了锁，立即返回true，如果等待超时，返回false.</p>
<p>4.lockInterruptibly():如果获取了锁，立即返回；如果没有获取锁，当前线程处于休眠状态，直至获得锁。它与lock()方法最大的不同在于如果lock()方法获取不到锁，会一直处于阻塞状态，且会忽略interrupt()方法。</p>
<h3 id="7-线程的暂停与恢复"><a href="#7-线程的暂停与恢复" class="headerlink" title="7.线程的暂停与恢复"></a><em>7.线程的暂停与恢复</em></h3><p>线程的暂停与恢复主要通过顶级父类Object提供的wait()方法与notify()方法实现，其中，wait()方法用来暂停线程，notify()用来唤醒正在等待的单个线程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/16/反射/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/16/反射/" itemprop="url">反射</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-16T21:12:44+08:00">
                2018-11-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Class类与java反射"><a href="#1-Class类与java反射" class="headerlink" title="1.Class类与java反射"></a><em>1.Class类与java反射</em></h3><p>java反射机制是在运行的过程中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的属性和方法的功能称为Java语言的反射机制。</p>
<h4 id="1-class类"><a href="#1-class类" class="headerlink" title="1.class类"></a>1.class类</h4><p>Class类的实例表示正在运行的Java应用程序中的类和接口，它没有公共构造方法，要创建class对象，有以下三种方法：</p>
<p>(1)使用类的class属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Demo.class;</span><br></pre></td></tr></table></figure>
<p>(2)使用Class类的forName方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    Class c = Class.forName(&quot;test.Demo&quot;);</span><br><span class="line">&#125;catch(ClassNotFoundException e1)&#123;</span><br><span class="line">    e1.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)使用Object对象的getClass方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Demo demo = new Demo();</span><br><span class="line">Class c = demo.getClass();</span><br></pre></td></tr></table></figure>
<p><strong>一个类只能有一个反射对象，即上述三种对象完全相同。</strong></p>
<p>通过反射可访问的主要描述信息</p>
<table>
<thead>
<tr>
<th style="text-align:center">组成部分</th>
<th style="text-align:center">访问方法</th>
<th style="text-align:center">返回值类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">包路径</td>
<td style="text-align:center">getPackage()</td>
<td style="text-align:center">Package对象</td>
<td style="text-align:center">获取该类的存放路径</td>
</tr>
<tr>
<td style="text-align:center">类名称</td>
<td style="text-align:center">getName()</td>
<td style="text-align:center">String对象</td>
<td style="text-align:center">获得该类的名称</td>
</tr>
<tr>
<td style="text-align:center">继承类</td>
<td style="text-align:center">getSuperclass()</td>
<td style="text-align:center">Class对象</td>
<td style="text-align:center">获得该类继承的类</td>
</tr>
<tr>
<td style="text-align:center">实现接口</td>
<td style="text-align:center">getInterfaces()</td>
<td style="text-align:center">Class型数组</td>
<td style="text-align:center">获取该类实现的所有接口</td>
</tr>
<tr>
<td style="text-align:center">构造方法</td>
<td style="text-align:center">getConstructors()</td>
<td style="text-align:center">Constructor型数组</td>
<td style="text-align:center">获得权限为public的构造方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getConstructor(Class&lt;?&gt;…parameterTypes)</td>
<td style="text-align:center">Constructor对象</td>
<td style="text-align:center">获取权限为public的指定构造方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclaredConstructors()</td>
<td style="text-align:center">Constructor型数组</td>
<td style="text-align:center">获得所有构造方法，按声明顺序返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td>
<td style="text-align:center">Constructor对象</td>
<td style="text-align:center">获取指定构造方法</td>
</tr>
<tr>
<td style="text-align:center">方法</td>
<td style="text-align:center">getMethods()</td>
<td style="text-align:center">Method型数组</td>
<td style="text-align:center">获得所有权限为public的方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getMethod(String name,Class&lt;?&gt;…paramterTypes)</td>
<td style="text-align:center">Method对象</td>
<td style="text-align:center">获得权限为public的方法</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclareMethods()</td>
<td style="text-align:center">Method型数组</td>
<td style="text-align:center">获得所有方法,按声明顺序返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclaredMethod(String name,Class&lt;?&gt;…parameterTypes)</td>
<td style="text-align:center">Method对象</td>
<td style="text-align:center">获得指定方法</td>
</tr>
<tr>
<td style="text-align:center">成员变量</td>
<td style="text-align:center">getFields()</td>
<td style="text-align:center">Field型数组</td>
<td style="text-align:center">获得所有权限为public的成员变量</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getField(String name)</td>
<td style="text-align:center">Field型对象</td>
<td style="text-align:center">获得权限为public的指定成员变量</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclareFields()</td>
<td style="text-align:center">Field型数组</td>
<td style="text-align:center">获得所有权限成员变量，按声明顺序返回</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclaredField(String name)</td>
<td style="text-align:center">Field对象</td>
<td style="text-align:center">获得指定成员变量</td>
</tr>
<tr>
<td style="text-align:center">内部类</td>
<td style="text-align:center">getClasses()</td>
<td style="text-align:center">Class型数组</td>
<td style="text-align:center">获得所有权限为public的内部类</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">getDeclaredField(String name)</td>
<td style="text-align:center">Class型数组</td>
<td style="text-align:center">获得所有内部类</td>
</tr>
<tr>
<td style="text-align:center">内部类的声明类</td>
<td style="text-align:center">getDeclaringClass()</td>
<td style="text-align:center">Class对象</td>
<td style="text-align:center">如果该类为内部类，则返回它的成员类，否则返回null</td>
</tr>
</tbody>
</table>
<h4 id="2-获取构造方法"><a href="#2-获取构造方法" class="headerlink" title="2.获取构造方法"></a>2.获取构造方法</h4><p>每个Constructor对象代表一个构造方法，利用Constructor对象可以操纵相应的构造方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">isVarArgs()</td>
<td style="text-align:center">查看该构造方法是否允许带有可变数量的参数如果允许则返回true,否则返回false</td>
</tr>
<tr>
<td style="text-align:center">getParameterTypes()</td>
<td style="text-align:center">按照声明顺序以Class数组的形式获得该构造方法的各个参数的类型</td>
</tr>
<tr>
<td style="text-align:center">getExceptionTypes()</td>
<td style="text-align:center">以Class数组的形式获得该构造方法可能抛出的异常类型</td>
</tr>
<tr>
<td style="text-align:center">newInstance(Object…initargs)</td>
<td style="text-align:center">通过构造方法利用指定参数创建一个该类的对象，如果为设置参数则表示采用默认无参数的构造方法</td>
</tr>
<tr>
<td style="text-align:center">setAccessible(boolean flag)</td>
<td style="text-align:center">如果该构造方法的权限为private,默认为不允许通过反射利用newInstance(Object…initargs)方法创建对象，如果先执行该方法，并将入口参数设为true,则允许创建</td>
</tr>
<tr>
<td style="text-align:center">getModifiers()</td>
<td style="text-align:center">获取可以解析出该构造方法所采用修饰符的整数</td>
</tr>
</tbody>
</table>
<h4 id="3-获取成员变量"><a href="#3-获取成员变量" class="headerlink" title="3.获取成员变量"></a>3.获取成员变量</h4><p>每个Field对象代表一个成员变量，利用Field对象可以操纵相应的成员变量。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getName()</td>
<td style="text-align:center">获得该成员变量的名称</td>
</tr>
<tr>
<td style="text-align:center">getType()</td>
<td style="text-align:center">获得表示该成员变量类型的Class对象</td>
</tr>
<tr>
<td style="text-align:center">get(Object obj)</td>
<td style="text-align:center">获取指定对象obj中成员变量的值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h4 id="4-获取方法"><a href="#4-获取方法" class="headerlink" title="4.获取方法"></a>4.获取方法</h4><h3 id="2-Annotation注解"><a href="#2-Annotation注解" class="headerlink" title="2.Annotation注解"></a><em>2.Annotation注解</em></h3><h4 id="1-内置注解"><a href="#1-内置注解" class="headerlink" title="1.内置注解"></a>1.内置注解</h4><h4 id="2-自定义注解"><a href="#2-自定义注解" class="headerlink" title="2.自定义注解"></a>2.自定义注解</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/Spring核心之AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/Spring核心之AOP/" itemprop="url">Spring核心之AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-15T21:06:52+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-AOP概述"><a href="#1-AOP概述" class="headerlink" title="1.AOP概述"></a><em>1.AOP概述</em></h3><h4 id="1-了解AOP"><a href="#1-了解AOP" class="headerlink" title="1.了解AOP"></a>1.了解AOP</h4><ul>
<li>切面：是一段程序代码，这段代码将被植入到程序流程中。</li>
<li>连接点：在程序流程上的任意一点，都可以是连接点。</li>
<li>切入点：是连接点的集合。切面是通过切入点被注入的。</li>
<li>通知：在切入点处拦截程序后，通过通知执行切面。</li>
<li>目标对象：所有被通知的对象。</li>
<li>织入：是将切面功能应用到目标对象的过程。</li>
<li>引入：对一个已编译完的类，在运行期间，动态地向这个类中加载属性和方法。</li>
</ul>
<h4 id="2-AOP的简单实现"><a href="#2-AOP的简单实现" class="headerlink" title="2.AOP的简单实现"></a>2.AOP的简单实现</h4><p>利用Spring AOP使日志输出与方法分离，让在调用目标对象之前执行日志输出。</p>
<p>1.首先创建类Target,他是被代理的目标对象。其中有个execute()方法，在执行该方法之前，做日志输出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Target&#123;</span><br><span class="line">public void execute(String name)&#123;</span><br><span class="line">    System.out.println(&quot;程序开始执行：&quot;+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.通知可以拦截目标对象的execute()方法，并执行日志输出，创建通知的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class LoggerExecute implements MethodInterceptor&#123;</span><br><span class="line">    public Object invoke(MethodInvocation invocation) throws Throwable&#123;</span><br><span class="line">        before();//执行前置通知</span><br><span class="line">        invocation.proceed();</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    //前置通知</span><br><span class="line">    private void before()&#123;</span><br><span class="line">        System.out.println(&quot;程序开始执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.若要使用AOP的功能必须创建代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Manage&#123;</span><br><span class="line">    //创建代理</span><br><span class="line">    Target target=new Target();</span><br><span class="line">    ProxyFactory di=new ProxyFactory();</span><br><span class="line">    di.addAdvice(new LoggerExecute());</span><br><span class="line">    di.setTarget(target);</span><br><span class="line">    Target proxy=(Target)di.getProxy();</span><br><span class="line">    proxy.execute(&quot;aop的简单实现&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Spring的切入点"><a href="#2-Spring的切入点" class="headerlink" title="2.Spring的切入点"></a><em>2.Spring的切入点</em></h3><h4 id="1-静态切入点与动态切入点"><a href="#1-静态切入点与动态切入点" class="headerlink" title="1.静态切入点与动态切入点"></a>1.静态切入点与动态切入点</h4><ul>
<li><p>静态切入点</p>
<p>静态意味着不变，例如一个对象的方法签名是固定不变的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;pointcutAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPOintcutAdvisor&quot;&gt;</span><br><span class="line">&lt;property name=&quot;advice&quot;&gt;</span><br><span class="line">&lt;ref bean=&quot;MyAdvisor&quot;/&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;patterns&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;.*getConn*.&lt;/value&gt;//指定所有以getConn开头的方法名都是切入点</span><br><span class="line">&lt;value&gt;.*closeConn*.&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>动态切入点</p>
<p>动态切入点应用在相对变化的位置，例如方法的参数上。。</p>
</li>
</ul>
<h4 id="2-深入静态切入点"><a href="#2-深入静态切入点" class="headerlink" title="2.深入静态切入点"></a>2.深入静态切入点</h4><p>静态切入点在某个方法名上是织入切面的，所以在织入切面代码前，要进行方法名的匹配。这个过程是spring自动进行的，不需要人为干预。</p>
<p>实际上Spring是使用boolean matches(Method,Class)方法来匹配切入点的，利用method.getName()方法反射取得正在运行的方法名。在boolean matches(Method,Class)方法中，Method是java.lang.reflect,Method类型，Class是目标对象的类型。该方法在AOP创建代理时被调用，并返回结果，true表示将切面织入，false表示不织入。</p>
<p>下面介绍静态切入点的匹配过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;pointcutAdvisor&quot; class=&quot;org.springframework.aop.support.RegexpMethodPOintcutAdvisor&quot;&gt;</span><br><span class="line">&lt;property name=&quot;patterns&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;.*execute*.&lt;/value&gt;//指定所有以execute开头的方法名都是切入点</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下是matches()方法匹配成功后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean matches(Method method,Class targetClass)&#123;</span><br><span class="line">    return (method.getName().equals(&quot;execute&quot;));//匹配切入点成功</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-深入动态切入点"><a href="#3-深入动态切入点" class="headerlink" title="3.深入动态切入点"></a>3.深入动态切入点</h4><p>pointcut接口是切入点的定义接口，用它来规定可切入的连接点的属性。</p>
<p>该切入点的接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface PointCut&#123;</span><br><span class="line">    ClassFilter getClassFilter();</span><br><span class="line">    MethodMatcher getMethodMatcher();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ClassFilter接口来匹配目标类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ClassFilter&#123;</span><br><span class="line">    boolean matches(Class class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用MethodMatcher接口来匹配目标类的方法或方法的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface MethodMatcher&#123;</span><br><span class="line">    boolean matches(Method m,Class targetClass);</span><br><span class="line">    boolean isRuntime();</span><br><span class="line">    boolean matches(Method m,Class targetClass,Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Spring中其他切入点"><a href="#4-Spring中其他切入点" class="headerlink" title="4.Spring中其他切入点"></a>4.Spring中其他切入点</h4><h3 id="3-Aspect对AOP的支持"><a href="#3-Aspect对AOP的支持" class="headerlink" title="3.Aspect对AOP的支持"></a><em>3.Aspect对AOP的支持</em></h3><h3 id="4-Spring持久化"><a href="#4-Spring持久化" class="headerlink" title="4.Spring持久化"></a><em>4.Spring持久化</em></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/Spring核心之IOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/Spring核心之IOC/" itemprop="url">Spring核心之IOC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-12T16:26:14+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a><em>1.Spring概述</em></h3><h4 id="1-初识spring"><a href="#1-初识spring" class="headerlink" title="1.初识spring"></a>1.初识spring</h4><p>spring是一个j2ee的框架，它以loc（控制反转）和aop(面向切面编程)两种先进的技术为基础，完美地简化了企业级开发的复杂度。</p>
<p>Spring框架主要由七大模块组成：</p>
<p>SpringCore核心模块：</p>
<p>spring框架的核心容器，它提供了spring框架的基本功能</p>
<p>SpringContext模块：</p>
<p>扩展核心容器，提供了spring上下文环境。</p>
<p>Spring Aop模块：</p>
<p>采用了面向切面编程的思想，使spring框架管理的对象支持aop。</p>
<p>Spring Dao模块：</p>
<p>提供了对数据访问对象模式和jdbc的支持。</p>
<p>Spring ORM映射模块：</p>
<p>提供了对现有框架ORM框架的支持。</p>
<p>Spring web模块：</p>
<p>提供了servlet监听器的context和web应用上下文。</p>
<p>Spring web MVC模块：</p>
<p>提供了web应用程序的MVC的实现。</p>
<h4 id="2-spring的获取"><a href="#2-spring的获取" class="headerlink" title="2.spring的获取"></a>2.spring的获取</h4><p>在spring的官方网站下载spring工具包，然后将spring.jar包和dist目录下的所有的jar包导入到项目中，随后就可以进行spring项目的开发。</p>
<h4 id="3-简单配置spring"><a href="#3-简单配置spring" class="headerlink" title="3.简单配置spring"></a>3.简单配置spring</h4><p>spring内置了日志组件log4j.jar，所以在正式使用spring之前需要对log4j进行简单的配置，在项目的src根目录下创建log4j.properties属性文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#输出级别，输出错误信息，输出源为标准输出源stdout</span><br><span class="line">log4j.rootLogger=WARN.stdout</span><br><span class="line">#将stdout输出到控制台中</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">#日志输出的布局类</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">#指定日志输出内容的格式</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d%p[%c]-%m%n</span><br></pre></td></tr></table></figure>
<p>spring配置结构：</p>
<p>jar包-&gt;tlb标签库-&gt;applicationContext.xml标签库-&gt;spring应用项目</p>
<h4 id="4-使用BeanFactory管理bean"><a href="#4-使用BeanFactory管理bean" class="headerlink" title="4.使用BeanFactory管理bean"></a>4.使用BeanFactory管理bean</h4><p>BeanFactory采用了Java经典的工厂模式，通过从XML配置文件或属性文件中读取JavaBean的定义，来实现JavaBean的创建，配置和管理。</p>
<p>XML配置元数据，Bean-&gt;BeanFactory-&gt;ApplicationContext</p>
<p>Spring中bean的生命周期包括实例化javaBean，初始化javaBean,使用javaBean,销毁javaBean。</p>
<h4 id="5-ApplicationContext的应用"><a href="#5-ApplicationContext的应用" class="headerlink" title="5.ApplicationContext的应用"></a>5.ApplicationContext的应用</h4><p>BeanFactory实现了loc控制，所以它可以称为“loc容器”,而ApplicationContext扩展了BeanFactory容器并添加了对国际化，生命周期事件的发布监听等更加强大的功能，使之成为spring中强大的企业级loc容器。</p>
<p>Application接口有三个实现类，可以实例化其中任何一个类来创建spring的application容器。</p>
<ul>
<li>ClassPathXmlApplicationContext类</li>
<li>FileSystemXmlApplicationContext类</li>
<li>WebApplicationContext类</li>
</ul>
<h3 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a><em>2.依赖注入</em></h3><h4 id="1-什么是控制反转和依赖注入"><a href="#1-什么是控制反转和依赖注入" class="headerlink" title="1.什么是控制反转和依赖注入"></a>1.什么是控制反转和依赖注入</h4><p>loc:即控制反转。它是程序组件或类之间尽量形成一种松耦合的结构，开发者在使用类的实例之前，需要创建对象的实例。但loc将创建实例的任务交给loc容器，这样开发应用代码时只需要使用对象的实例，这就是loc.</p>
<p>依赖注入有三种实现类型，spring支持后两种。</p>
<ul>
<li>接口注入</li>
<li>setter注入</li>
<li>构造器注入</li>
</ul>
<h4 id="2-Bean的配置"><a href="#2-Bean的配置" class="headerlink" title="2.Bean的配置"></a>2.Bean的配置</h4><p>想要在Springloc容器中获取一个Bean，首先要在配置文件中的《beans》元素中配置一个子元素《bean》,spring的控制反转机制会根据《bean》元素的具体配置来实例化这个Bean实例。</p>
<p>eg:</p>
<p>《bean id=”test” class=”com.mr.Test”》</p>
<p>这样就可以通过BeanFactory容器的getBean(“test”)方法就可以获取到该类的实例。</p>
<h4 id="3-setter注入"><a href="#3-setter注入" class="headerlink" title="3.setter注入"></a>3.setter注入</h4><p>配置文件中的《property》元素可以为javaBean的setter()方法传参，即通过setter方法为属性赋值。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;user&quot; class=&quot;com.mr.user.User&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;name&quot;&gt;</span><br><span class="line">       &lt;value&gt;小强&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-构造器注入"><a href="#4-构造器注入" class="headerlink" title="4.构造器注入"></a>4.构造器注入</h4><p>《construct-arg》是《bean》元素的子元素，通过《construct-arg》元素的《value》子元素可以为构造方法传参。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;user&quot; class=&quot;com.mr.user.User&quot;&gt;</span><br><span class="line">  &lt;construct-arg&gt;</span><br><span class="line">       &lt;value&gt;小强&lt;/value&gt;</span><br><span class="line">  &lt;/construct-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-引用其他Bean"><a href="#5-引用其他Bean" class="headerlink" title="5.引用其他Bean"></a>5.引用其他Bean</h4><p>在spring中可以通过配置文件使用《ref》元素引用其他javaBean的实例对象。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;/main.do&quot; class=&quot;com.mr.user.User&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;user&quot;&gt;</span><br><span class="line">      &lt;ref local=&quot;user&quot;/&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="6-匿名内部javaBean的创建"><a href="#6-匿名内部javaBean的创建" class="headerlink" title="6.匿名内部javaBean的创建"></a>6.匿名内部javaBean的创建</h4><p>在需要匿名内部类的地方直接用《bean》标签定义一个内部类即可。如果要使用这个内部类匿名，可以不指定《bean》标签的id或name属性。</p>
<h3 id="3-自动装配"><a href="#3-自动装配" class="headerlink" title="3.自动装配"></a><em>3.自动装配</em></h3><h4 id="1-按bean的名称装配"><a href="#1-按bean的名称装配" class="headerlink" title="1.按bean的名称装配"></a>1.按bean的名称装配</h4><p>《bean》元素的byname属性名区分自动装配。在容器中寻找与javaBean属性名相同的javaBean,并将其自动装配到javaBean中。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean autowire=&quot;byName&quot; id=&quot;printInfo&quot; class=&quot;com.mr.user.PrintInfo&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-按bean类型装配"><a href="#2-按bean类型装配" class="headerlink" title="2.按bean类型装配"></a>2.按bean类型装配</h4><p>《bean》元素的byType属性名区分自动装配。在容器中寻找与javaBean属性类型相同的javaBean,并将其自动装配到javaBean中。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean autowire=&quot;byType&quot; id=&quot;printInfo&quot; class=&quot;com.mr.user.PrintInfo&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-自动装配的其他方式"><a href="#3-自动装配的其他方式" class="headerlink" title="3.自动装配的其他方式"></a>3.自动装配的其他方式</h4><h5 id="1-no属性"><a href="#1-no属性" class="headerlink" title="1.no属性"></a>1.no属性</h5><p>这是autoWire采用的默认值，它采用自动装配。</p>
<h5 id="2-constructor属性"><a href="#2-constructor属性" class="headerlink" title="2.constructor属性"></a>2.constructor属性</h5><p>通过构造方法的参数类型自动装配。</p>
<h5 id="3-autodetect属性"><a href="#3-autodetect属性" class="headerlink" title="3.autodetect属性"></a>3.autodetect属性</h5><p>它首先会使用constructor方式来自动装配，然后使用byType方式。，当然它也存在与byType和constructor相同的异常情况。</p>
<h3 id="4-bean的作用域"><a href="#4-bean的作用域" class="headerlink" title="4.bean的作用域"></a><em>4.bean的作用域</em></h3><h4 id="1-了解spring中的bean"><a href="#1-了解spring中的bean" class="headerlink" title="1.了解spring中的bean"></a>1.了解spring中的bean</h4><p>Bean是由spring容器初始化，装配及被管理的对象。</p>
<h4 id="2-singleton的作用域"><a href="#2-singleton的作用域" class="headerlink" title="2.singleton的作用域"></a>2.singleton的作用域</h4><p>当spring中一个Bean的作用域为singleton时，那么springIoc容器中只会存在一个共享的该bean实例。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;test&quot; class=&quot;com.mr.Test&quot;/&gt; //默认即为singleton作用域</span><br><span class="line">&lt;bean id=&quot;test&quot; class=&quot;com.mr.Test&quot; singleton=&quot;true&quot;/&gt; //将singleton属性设置为true</span><br><span class="line">&lt;bean id=&quot;test&quot; class=&quot;com.mr.Test&quot; scope=&quot;singleton&quot;&gt; //利用scope属性指定</span><br></pre></td></tr></table></figure>
<h4 id="3-prototype的作用域"><a href="#3-prototype的作用域" class="headerlink" title="3.prototype的作用域"></a>3.prototype的作用域</h4><p>当spring中一个Bean的作用域为prototype时会导致每次对该Bean请求时都会创建一个新的bean实例。</p>
<p>eg:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;test&quot; class=&quot;com.mr.Test&quot; singleton=&quot;false&quot;/&gt; //将singleton属性设置为false</span><br><span class="line">&lt;bean id=&quot;test&quot; class=&quot;com.mr.Test&quot; scope=&quot;prototype&quot;&gt; //利用scope属性指定</span><br></pre></td></tr></table></figure>
<p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/Ajax技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/Ajax技术/" itemprop="url">Ajax技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-08T20:52:47+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-当下谁在用Ajax"><a href="#1-当下谁在用Ajax" class="headerlink" title="1.当下谁在用Ajax"></a><em>1.当下谁在用Ajax</em></h3><h3 id="2-ajax开发模式与传统开发模式的比较"><a href="#2-ajax开发模式与传统开发模式的比较" class="headerlink" title="2.ajax开发模式与传统开发模式的比较"></a><em>2.ajax开发模式与传统开发模式的比较</em></h3><p>由于ajax是一个客户端技术，所以无论使用那种服务端技术都可以使用ajax。</p>
<p>传统：在传统的web应用模式中，页面每一次操作都将会触发一次返回web服务器的HTTP请求，服务器进行相应的处理后，返回一个HTML页面给客户端。</p>
<p>ajax：而在ajax应用中，页面中用户的操作将通过ajax引擎与服务器进行通信，然后将返回结果提交给客户端页面的ajax引擎，再由ajax引擎来决定将这些数据插入到页面的指定位置。</p>
<p>优点：在ajax应用开发模式中通过JavaScript实现在不刷新整个页面的情况下，对部分数据进行更新，从而降低了网络流量，给用户带来更好的体验。</p>
<h3 id="3-ajax使用的技术"><a href="#3-ajax使用的技术" class="headerlink" title="3.ajax使用的技术"></a><em>3.ajax使用的技术</em></h3><p>Ajax是XMLHttpRequest对象和JavaScript,XML,CSS,DOM（文档对象模型）等技术的组合。</p>
<h3 id="4-使用XMLHttpRequest对象"><a href="#4-使用XMLHttpRequest对象" class="headerlink" title="4.使用XMLHttpRequest对象"></a><em>4.使用XMLHttpRequest对象</em></h3><h5 id="1-初始化XMLHttpRequst对象"><a href="#1-初始化XMLHttpRequst对象" class="headerlink" title="1.初始化XMLHttpRequst对象"></a>1.初始化XMLHttpRequst对象</h5><p>if(windom.XMLHttpRequest){ //非IE浏览器</p>
<p>http_request=new XMLHttpRequest();</p>
<p>}else if(window.ActiveXObject){//IE浏览器</p>
<p>try{</p>
<p>http_request=new ActiveXObject(“Msxml2.XMLHTTP”);</p>
<p>}catch(e){</p>
<p>try{</p>
<p>http_request=new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<p>}catch(e){}</p>
<p>}</p>
<p>}</p>
<h5 id="2-XMLHttpRequest对象的常用方法"><a href="#2-XMLHttpRequest对象的常用方法" class="headerlink" title="2.XMLHttpRequest对象的常用方法"></a>2.XMLHttpRequest对象的常用方法</h5><ul>
<li><p>open()方法</p>
<p>用于设置进行异步请求目标的URL，请求方法以及其他参数信息</p>
<p>语法:</p>
<p>open(“method”,”url”[,asyncFlag[,”userName”,[“password”]]])</p>
<p>method：用于指定请求的类型，一般为get或post</p>
<p>url:用于指定请求的地址，可以使用绝对地址或相对地址。</p>
<p>asyncFlag:为可选参数，用于指定请求方式，异步请求为true,同步请求为false,默认为true。</p>
<p>userName：为可选参数，用于指定请求用户名，没有时可以省略。</p>
<p>password：为可选参数，用于指定请求密码，没有时可以省略。</p>
</li>
<li><p>send()方法</p>
<p>send()方法用于向服务器发送请求，如果请求声明为异步，该方法将立即返回，否则将等到接收到响应为止。</p>
<p>语法：</p>
<p>send(content)</p>
<p>content:用于指定发送的数据</p>
</li>
<li><p>setRequestHeader()方法</p>
<p>setRequestHeader()方法用于为请求的HTTP头设置值。</p>
<p>语法：</p>
<p>setRequestHeader(“header”,”value”)</p>
<p>header：用于设置HTTP头</p>
<p>value：用于为指定的HTTP头设置值</p>
</li>
<li><p>getAllResponseHeaders()方法</p>
<p>用于以字符串形式返回完整的HTTP头信息</p>
</li>
</ul>
<h5 id="3-XMLHttpRequest的常用属性"><a href="#3-XMLHttpRequest的常用属性" class="headerlink" title="3.XMLHttpRequest的常用属性"></a>3.XMLHttpRequest的常用属性</h5><ul>
<li><p>onreadystatechange属性</p>
<p>用于指定状态改变时所触发的事件处理器。</p>
<p>eg:指定状态改变时所触发javaScript函数getResult的代码：</p>
<p>http_request.onreadystatechange=getResult;</p>
</li>
<li><p>readyState属性</p>
<p>用于获取请求的状态。</p>
<p>0：为初始化</p>
<p>1：正在加载</p>
<p>2：已加载</p>
<p>3：交互中</p>
<p>4：完成</p>
</li>
<li><p>responseText属性</p>
<p>用于获取服务器的响应，表示为字符串</p>
</li>
<li><p>responseXML属性</p>
<p>用于获取服务器的响应，表示为XML</p>
</li>
<li><p>status属性</p>
<p>用于返回服务器的HTTP状态码</p>
<p>200：表示成功</p>
<p>202：表示请求被接受，但尚未成功</p>
<p>400：错取的请求</p>
<p>404：文件未找到</p>
<p>500：内部服务器错误</p>
</li>
<li><p>statusText属性</p>
<p>用于返回HTTP状态码对应的文本</p>
</li>
</ul>
<h3 id="5-：服务器通信——发送请求与处理响应"><a href="#5-：服务器通信——发送请求与处理响应" class="headerlink" title="5.：服务器通信——发送请求与处理响应"></a><em>5.：服务器通信——发送请求与处理响应</em></h3><h5 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h5><ul>
<li>初始化XMLHttpRequest对象</li>
<li>为XMLHttpRequest对象指定一个返回结果处理函数（回调函数）</li>
<li>创建一个与服务器的连接</li>
<li>向服务器发送请求</li>
</ul>
<h5 id="2-处理服务器响应"><a href="#2-处理服务器响应" class="headerlink" title="2.处理服务器响应"></a>2.处理服务器响应</h5><p>XMLHttpRequest对象提供了两个用来访问服务器响应的属性一个是requestText属性，返回的是字符串响应，另一个是responseXML属性，返回XML响应。</p>
<h3 id="6-解决中文乱码问题"><a href="#6-解决中文乱码问题" class="headerlink" title="6.解决中文乱码问题"></a><em>6.解决中文乱码问题</em></h3><p>Ajax不支持多种字符集，它默认的字符集是utf-8，所以默认在应用ajax技术的程序中应及时进行编码转换，否则中文乱码。</p>
<p>一般情况下，有以下两种情况可以出现中文乱码：</p>
<p>发送请求时出现中文乱码</p>
<p>获取服务器的响应结果时出现中文乱码</p>
<h3 id="7-ajax重构"><a href="#7-ajax重构" class="headerlink" title="7.ajax重构"></a><em>7.ajax重构</em></h3><p>ajax重构大致可以分成以下三个步骤：</p>
<p>1.创建一个单独的js文件</p>
<p>2.在需要应用ajax的页面中应用以下渔具包括步骤一中创建的js文件</p>
<p>3.在需要应用ajax的页面中编写错误处理方法</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/JSTL标签库简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/JSTL标签库简介/" itemprop="url">JSTL标签库简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-06T22:03:56+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-标签库简介"><a href="#1-标签库简介" class="headerlink" title="1.标签库简介"></a><em>1.标签库简介</em></h3><p>标准标签库实际上是由五个功能不同的标签库组成。分别是：核心标签库，格式标签库，SQL标签库，XML标签库和函数标签库。</p>
<p>核心标签库主要用于完成JSP页面的常用功能，包括jstl的表达式标签，url标签，流程控制标签，循环标签。</p>
<h3 id="2-JSTL的配置"><a href="#2-JSTL的配置" class="headerlink" title="2.JSTL的配置"></a><em>2.JSTL的配置</em></h3><p>由于jstl还不是JSP2.0中的一部分，所以使用之前需要安装并配置jstl。</p>
<p>现在oracle公司官网上下载，然后就可以在web应用中进行配置。配置一共有两种方法：一种是直接将jstl-api-1.2.jar和jstl.impl-1.2.jar复制到web-inf\lib目录，另一种是在eclipse中通过配置构建路径的方法进行添加。</p>
<h3 id="3-表达式标签"><a href="#3-表达式标签" class="headerlink" title="3.表达式标签"></a><em>3.表达式标签</em></h3><h5 id="1-《c-out》输出标签"><a href="#1-《c-out》输出标签" class="headerlink" title="1.《c:out》输出标签"></a>1.《c:out》输出标签</h5><p>语法一——没有标签体</p>
<p>《c:out value=”expression” [escapeXml=”true|false” [default=”true|false”]》</p>
<p>语法二——有标签体</p>
<p>《c:out value=”expression” [escapeXml=”true|false”] /》</p>
<p>   defalutValue</p>
<p>《/c:out》</p>
<p>value:用于指定将要输出的变量或表达式</p>
<p>escapeXml:可选属性，用于指定是否转换为特殊字符。</p>
<p>default:可选属性，用于指定value属性值等于nul时，将要显示的默认值。</p>
<h5 id="2-《c-set》变量设置标签"><a href="#2-《c-set》变量设置标签" class="headerlink" title="2.《c:set》变量设置标签"></a>2.《c:set》变量设置标签</h5><p>语法一——在scope指定的范围内将变量值存储到变量中</p>
<p>《c:set var=”name” value=”value” [scope=”范围”]/》</p>
<p>语法二——在scope指定的范围内将标签体存储到变量中</p>
<p>《c:set var=”name” [scope=”page|request|session|application”]》</p>
<p>标签体</p>
<p>《/c:set》</p>
<p>语法三——将变量值存储在target属性指定的目标对象的propName属性中。</p>
<p>《c:set value=”value” target=”object” property=”proName”/》</p>
<p>语法四——将标签体存储到target属性指定的目标对象的propName属性中。</p>
<p>《c:set target=”object” property=”proName”》</p>
<p>标签体</p>
<p>《/c:set》</p>
<p>var:用于指定变量名</p>
<p>value：用于指定变量值</p>
<p>scope：用于指定变量的作用域</p>
<p>target:用于指定存储变量值或者标签体的目标对象</p>
<p>property:用于指定目标对象存储数据的属性名</p>
<h5 id="3-《c-remove》变量移除标签"><a href="#3-《c-remove》变量移除标签" class="headerlink" title="3.《c:remove》变量移除标签"></a>3.《c:remove》变量移除标签</h5><p>《c:remove var=”name” [scope=”范围”]》</p>
<p>var:用于指定要移除的变量名</p>
<p>scope:用于指定变量的有效范围</p>
<h5 id="4-《c-catch》捕获异常标签"><a href="#4-《c-catch》捕获异常标签" class="headerlink" title="4.《c:catch》捕获异常标签"></a>4.《c:catch》捕获异常标签</h5><p>该标签用于捕获程序中出现的异常，该标签与Java中的try…catch语句类似。</p>
<p>《c:catch [var=”exception”]》</p>
<p>…//可能存在异常的代码</p>
<p>《/c:catch》</p>
<p>var:可选属性，用于指定存储异常信息的变量，如果不需要保存异常信息，可以忽略该属性。</p>
<h3 id="4-URL相关标签"><a href="#4-URL相关标签" class="headerlink" title="4.URL相关标签"></a><em>4.URL相关标签</em></h3><h5 id="1-《c-import》导入标签"><a href="#1-《c-import》导入标签" class="headerlink" title="1.《c:import》导入标签"></a>1.《c:import》导入标签</h5><p>语法一：</p>
<p>《c:import url=”url” [context=”context” [var=”name” [scope=”范围” [charEncoding=”encoding”]》</p>
<p>[标签体]</p>
<p>《/c:import》</p>
<p>语法二：</p>
<p>《c:import url=”url” varReader=”name” [context=”context” [charEncoding=”encoding”]》</p>
<p>[标签体]</p>
<p>《/c:import》</p>
<p>url:用于指定被导入文件资源的url地址</p>
<p>context：上下文路径，用于访问同一服务器的其他web应用，其值必须以“/”开头，如果指定了该属性，那么url属性值也必须以“/“开头。</p>
<p>var:用于指定变量名称</p>
<p>scope；用于指定变量的存在范围，默认值是page。可选值为page,session,request,application.</p>
<p>varReader:定义一个变量名，该变量用于以reader类型存储被包含文件内容。</p>
<p>charEncoding:用于指定被导入文件的编码格式。</p>
<p>标签体：可选，如果需要为导入的文件传递参数，则可以在标签提的位置通过《c:param》标签设置参数。</p>
<h5 id="2-《c-url》动态生成URL标签"><a href="#2-《c-url》动态生成URL标签" class="headerlink" title="2.《c:url》动态生成URL标签"></a>2.《c:url》动态生成URL标签</h5><p>语法一：</p>
<p>《c:url value=”url” [var=”name” [scope=”范围” [context=”context”]/》</p>
<p>语法二：</p>
<p>《c:url value=”url” [var=”name” [scope=”范围” [context=”context”]》</p>
<p>《c:param/》</p>
<p>…</p>
<p>《/c:url》</p>
<p>value:用于指定将要处理的url地址</p>
<p>context：上下文路径，用于访问同一服务器的其他web应用，其值必须以“/”开头，如果指定了该属性，那么url属性值也必须以“/“开头。</p>
<p>var:用于指定变量名称</p>
<p>scope；用于指定变量的存在范围，默认值是page。可选值为page,session,request,application.</p>
<h5 id="3-《c-redirect》重定向标签"><a href="#3-《c-redirect》重定向标签" class="headerlink" title="3.《c:redirect》重定向标签"></a>3.《c:redirect》重定向标签</h5><p>语法一：</p>
<p>《c:redirect url=”url” [context=”context”]/》</p>
<p>语法二：</p>
<p>《c:redirect url=”url” [context=”context”]》</p>
<p>《c:param/》</p>
<p>《/c:redirect》</p>
<p>url:必选属性，用于指定待定向资源的URL，可以使用EL.</p>
<p>context:用于在使用相对路径访问外部context资源时，指定资源的名字。</p>
<h5 id="4-《c-param》传递参数标签"><a href="#4-《c-param》传递参数标签" class="headerlink" title="4.《c:param》传递参数标签"></a>4.《c:param》传递参数标签</h5><p>《c:param name=”paramName” value=”paramValue”/》</p>
<p>name:用于指定参数名</p>
<p>value:用于指定参数值</p>
<h3 id="5-流程控制标签"><a href="#5-流程控制标签" class="headerlink" title="5.流程控制标签"></a><em>5.流程控制标签</em></h3><h5 id="1-《c-if》条件判断标签"><a href="#1-《c-if》条件判断标签" class="headerlink" title="1.《c:if》条件判断标签"></a>1.《c:if》条件判断标签</h5><p>语法一：</p>
<p>《c:if test=”condition” var=”name” [scope=page|session|request|session|application]/》</p>
<p>语法二：</p>
<p>《c:if test=”condition” var=”name” [scope=page|session|request|session|application]》</p>
<p>标签体</p>
<p>《/c:if》</p>
<h5 id="2-《c-choose》条件选择标签"><a href="#2-《c-choose》条件选择标签" class="headerlink" title="2.《c:choose》条件选择标签"></a>2.《c:choose》条件选择标签</h5><p>《c:choose》</p>
<p>标签体 ——由《c:when》和《c:otherwise》标签组成</p>
<p>《/c:choose》</p>
<h5 id="3-《c-when》条件测试标签"><a href="#3-《c-when》条件测试标签" class="headerlink" title="3.《c:when》条件测试标签"></a>3.《c:when》条件测试标签</h5><p>《c:when test=”condition”》</p>
<p>标签体</p>
<p>《/c:when》</p>
<h5 id="4-《c-otherwise》其他条件标签"><a href="#4-《c-otherwise》其他条件标签" class="headerlink" title="4.《c:otherwise》其他条件标签"></a>4.《c:otherwise》其他条件标签</h5><p>《c:otherwise》</p>
<p>标签体</p>
<p>《/c:otherwise》</p>
<h3 id="6-循环标签"><a href="#6-循环标签" class="headerlink" title="6.循环标签"></a><em>6.循环标签</em></h3><h5 id="1-《c-forEach》循环标签"><a href="#1-《c-forEach》循环标签" class="headerlink" title="1.《c:forEach》循环标签"></a>1.《c:forEach》循环标签</h5><p>语法一：集合成员迭代</p>
<p>《c:forEach items=”data” [var=”name” [begin=”start” [end=”finish” [step=”step” [varStatus=”statusName”》</p>
<p>标签体</p>
<p>《/c:foEach》</p>
<p>语法二：数字索引迭代</p>
<p>《c:forEach begin=”start” end=”finish” [var=”name” [varStatus=”statusName” [step=”step”]》</p>
<p>标签体</p>
<p>《/c:forEach》</p>
<p>items；用于指定被循环遍历对象</p>
<p>var:用于指定循环体的变量名</p>
<p>begin:用于指定循环的起始位置</p>
<p>end:用于指定循环的终止位置</p>
<p>step:用于指定循环的步长</p>
<p>varStatus:用于指定循环的状态变量，有四个状态属性</p>
<p>如下：</p>
<p>index——当前循环的索引值(Int)</p>
<p>count——当前循环的循环计数(Int)</p>
<p>first——是否为第一次循环(boolean)</p>
<p>last——是否为最后一次循环(boolean)</p>
<h5 id="2-《c-forTokens》迭代标签"><a href="#2-《c-forTokens》迭代标签" class="headerlink" title="2.《c:forTokens》迭代标签"></a>2.《c:forTokens》迭代标签</h5><p>该标签可以用指定的分隔符将一个字符串分隔开，根据分割的数量确定循环的次数。</p>
<p>《c:forTokens items=”String” delim=”char” [var=”name” [begin=”start” [end=”end” [step=”len” [varStatus=”statusName”]》</p>
<p>标签体</p>
<p>《/c:forTokens》</p>
<p>items:用于指定要迭代的String对象</p>
<p>delims:用于指定分割字符串的分隔符,可以同时有多个分隔符</p>
<p>var:用于指定变量名，该变量中保存了分割后的字符串</p>
<p>begin:用于指定迭代开始的位置，索引值从开始</p>
<p>end:用于指定迭代结束的位置</p>
<p>step:用于指定迭代的步长，默认为1</p>
<p>varStatus：用于指定循环的状态变量，同《c:forEach》一样,该属性也有四个状态变量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/EL表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/EL表达式/" itemprop="url">EL表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-05T20:51:21+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-EL表达式概述"><a href="#1-EL表达式概述" class="headerlink" title="1.EL表达式概述"></a><em>1.EL表达式概述</em></h3><p>EL是表达式语言，它是JSP2.0中引入的一个新内容。通过EL表达式可以简化在JSP开发中对对象的引用，从而规范页面代码，增加程序的可读性及可维护性。</p>
<h4 id="1-EL表达式的语法"><a href="#1-EL表达式的语法" class="headerlink" title="1.EL表达式的语法"></a>1.EL表达式的语法</h4><p>${expression}</p>
<h4 id="2-EL的特点"><a href="#2-EL的特点" class="headerlink" title="2.EL的特点"></a>2.EL的特点</h4><h3 id="2-与低版本的环境兼容——禁用EL"><a href="#2-与低版本的环境兼容——禁用EL" class="headerlink" title="2.与低版本的环境兼容——禁用EL"></a><em>2.与低版本的环境兼容——禁用EL</em></h3><h6 id="1-使用斜杠“-”符号"><a href="#1-使用斜杠“-”符号" class="headerlink" title="1.使用斜杠“\”符号"></a>1.使用斜杠“\”符号</h6><p>\ ${expression}</p>
<h6 id="2-使用page指令"><a href="#2-使用page指令" class="headerlink" title="2.使用page指令"></a>2.使用page指令</h6><p>《%@ page isELIgnored=”布尔值”》</p>
<p>若属性为true，则表明忽略页面中的EL。</p>
<h6 id="3-在web-xml文件中配置《el-ignored》元素"><a href="#3-在web-xml文件中配置《el-ignored》元素" class="headerlink" title="3.在web.xml文件中配置《el-ignored》元素"></a>3.在web.xml文件中配置《el-ignored》元素</h6><p>该方法适用于禁用web应用中所有JSP页面中的EL。</p>
<p>《jsp-config》</p>
<p>《jsp-property-group》</p>
<p>《url-pattern》*.jsp《/url-pattern》</p>
<p>《el-ignored》true《/el-ignored》</p>
<p>《/jsp-property-group》</p>
<p>《/jsp-config》</p>
<h3 id="3-保留的关键字"><a href="#3-保留的关键字" class="headerlink" title="3.保留的关键字"></a><em>3.保留的关键字</em></h3><p>同Java一样，EL也有自己的保留关键字，再为变量命名时，应该避免使用这些关键字。</p>
<h3 id="4-EL的运算符及优先级"><a href="#4-EL的运算符及优先级" class="headerlink" title="4.EL的运算符及优先级"></a><em>4.EL的运算符及优先级</em></h3><p>[]</p>
<p>()</p>
<p>-(负号) not ! empty</p>
<p>*/ div % mod</p>
<p>+(加号)  -(减号)</p>
<p>&lt; &gt; &lt;= &gt;= lt gt le ge</p>
<p>== != eq ne</p>
<p>&amp;&amp; and</p>
<p>|| or</p>
<p>?:</p>
<p>优先级由高到低</p>
<h4 id="1-通过EL访问数据"><a href="#1-通过EL访问数据" class="headerlink" title="1.通过EL访问数据"></a>1.通过EL访问数据</h4><p>通常情况下，”[]”和“.”是等价的。</p>
<p>${userInfo.id}</p>
<p>${userInfo[id]}</p>
<p>但当属性名中包含一些特殊符号(-或.)时，就只能用“[]”运算符来访问对象的属性。另外。数组元素或list集合中数据的获取，也应该用“.”运算符。</p>
<h4 id="2-在EL中进行算术运算"><a href="#2-在EL中进行算术运算" class="headerlink" title="2.在EL中进行算术运算"></a>2.在EL中进行算术运算</h4><p>EL提供了加减乘除和求余五种算术运算。但“+”与Java中的不同，他不能实现两个字符串之间的连接，只能将数值型字符串转换为数值型，在进行加法运算，否则将抛异常。</p>
<h4 id="3-在EL表达式中判断对象是否为空"><a href="#3-在EL表达式中判断对象是否为空" class="headerlink" title="3.在EL表达式中判断对象是否为空"></a>3.在EL表达式中判断对象是否为空</h4><p>${empty expression}</p>
<p>判断非空</p>
<p>${not empty expression}</p>
<h4 id="4-在EL中进行逻辑关系运算"><a href="#4-在EL中进行逻辑关系运算" class="headerlink" title="4.在EL中进行逻辑关系运算"></a>4.在EL中进行逻辑关系运算</h4><ul>
<li><p>关系运算符</p>
<p>== eq</p>
<p>!= ne</p>
<p>&lt; lt</p>
<p>大于 gt</p>
<p>&lt;= le</p>
<p>大于等于 ge</p>
</li>
<li><p>逻辑运算符</p>
<p>&amp;&amp; and</p>
<p>|| or</p>
<p>! not</p>
</li>
</ul>
<h4 id="5-在EL中进行条件运算"><a href="#5-在EL中进行条件运算" class="headerlink" title="5.在EL中进行条件运算"></a>5.在EL中进行条件运算</h4><p>${条件表达式？表达式一：表达式二}</p>
<h3 id="5-EL的隐含对象"><a href="#5-EL的隐含对象" class="headerlink" title="5.EL的隐含对象"></a><em>5.EL的隐含对象</em></h3><h4 id="1-页面上下文对象"><a href="#1-页面上下文对象" class="headerlink" title="1.页面上下文对象"></a>1.页面上下文对象</h4><p>页面上下文对象为pageContext，用于访问JSP内置对象(如request,response,session,out,page,exception,但不能用于pageContext,config,application)和servletContext。在获取这些内置对象之后，就可以获得其属性值，这些属性值与对象的getXXX()方法相对应，在使用时，去掉方法名中的get,并将首字母改为小写即可。</p>
<p>eg:访问request对象</p>
<p>${pageContext.request}</p>
<p>访问其中的getServerPort()方法</p>
<p>${pageContext.request.serverPort}</p>
<p><strong>注：不可以通过pageContext对象获取保存到request范围中的变量。</strong></p>
<h4 id="2-访问作用域范围的隐含对象"><a href="#2-访问作用域范围的隐含对象" class="headerlink" title="2.访问作用域范围的隐含对象"></a>2.访问作用域范围的隐含对象</h4><p>在EL中提供了四个用于访问作用域范围的隐含对象，即pageScope,requestScope,sessionScope,applicationScope。这四个隐含对象只能取得指定范围内的属性值，而不能取得其他相关信息。</p>
<p>eg:《%request.setAttribute(“userName”,”mr”)%》</p>
<p>$(requestScope.userName)</p>
<h4 id="3-访问环境信息的隐含对象"><a href="#3-访问环境信息的隐含对象" class="headerlink" title="3.访问环境信息的隐含对象"></a>3.访问环境信息的隐含对象</h4><p>在EL中提供了留个访问环境的隐含对象。</p>
<ul>
<li><p>param对象</p>
<p>用于获取请求参数的值，应用在参数值只有一个的情况。</p>
<p>eg:</p>
<p>《input name=”name” value=”text”》</p>
<p>${param.name}</p>
</li>
<li><p>paramValues对象</p>
<p>应用与请求参数名对应多个值时，返回结果为数组。</p>
<p>eg:</p>
<p>《input name=”name” value=”text”》</p>
<p>《input name=”name” value=”text”》</p>
<p>${paramValues.name[0]}</p>
<p><strong>注：在应用param和paramValues对象时，若果指定参数不存在，则返回空的字符串。而不是null。</strong></p>
</li>
<li><p>header和headerValues对象</p>
<p>header对象用于获取HTTP请求的一个具体的header的值。若可能存在同一个header拥有多个不同的情况，这就必须用headerValues对象。</p>
<p>eg:要获取HTTP请求的header的connection(是否持久连接)属性</p>
<p>${header.connection}</p>
</li>
<li><p>initParam对象</p>
<p>该对象用于获取web应用初始化参数。</p>
<p>eg:获取web应用的web.xml文件中设置一个初始化参数author，用于指定作者。</p>
<p>《context-param》</p>
<p>《param-name》author《/param-name》</p>
<p>《param-value》mr《/param-value》</p>
<p>《/context-param》</p>
<p>${initParam.author}</p>
</li>
<li><p>cookie对象</p>
<p>虽然EL中，并没有提供向cookie中保存值的方法，但是它提供了访问由请求设置的cookie的方法，这可以通过cookie的隐含对象实现。</p>
<p>eg:使用response对象设置一个请求有效的cookie对象，然后在使用EL获取该cookie的值。</p>
<p>《%Cookie cookie=new Cookie(“user”,”mr”)</p>
<p>response.addCookie(cookie);</p>
<p>%》</p>
<p>${cookie.user.value}</p>
</li>
</ul>
<h3 id="6-定义和使用EL函数"><a href="#6-定义和使用EL函数" class="headerlink" title="6.定义和使用EL函数"></a><em>6.定义和使用EL函数</em></h3><p>(1)编写一个Java类，并在该类中编写公用静态方法，用于实现自定义EL函数的具体功能。</p>
<p>(2)编写标签库描述文件，对函数进行声明。该文件的拓展名为.tld，被保存到web应用的web-inf文件夹下。</p>
<p>(3)在JSP页面中引用标签库，并调用定义的EL函数，实现相应的功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/java-web的数据库操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/java-web的数据库操作/" itemprop="url">java web的数据库操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-04T16:46:32+08:00">
                2018-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-JDBC技术"><a href="#1-JDBC技术" class="headerlink" title="1.JDBC技术"></a><em>1.JDBC技术</em></h3><h4 id="1-jdbc简介"><a href="#1-jdbc简介" class="headerlink" title="1.jdbc简介"></a>1.jdbc简介</h4><p>jdbc是Java程序操作数据库的API。</p>
<h4 id="2-jdbc连接数据库的过程"><a href="#2-jdbc连接数据库的过程" class="headerlink" title="2.jdbc连接数据库的过程"></a>2.jdbc连接数据库的过程</h4><ul>
<li><p>注册数据库驱动</p>
<p>Class.forName(“com.mysql.jdbc.Driver”)</p>
</li>
<li><p>构造数据库连接url</p>
<p>DriverManager.getConnection(url,username,password)</p>
</li>
</ul>
<h3 id="2-JDBC-API"><a href="#2-JDBC-API" class="headerlink" title="2.JDBC API"></a><em>2.JDBC API</em></h3><p>1.connection接口</p>
<p>connection接口位于java.sql包中，是与特定数据库的连接对话。</p>
<p>2.DriverManager类</p>
<p>它是jdbc中的管理层，通过DriverManager类可以管理数据库厂商提供的驱动程序，并建立应用程序与数据库之间的连接。</p>
<p>3.Statement接口</p>
<p>它封装了jdbc执行sql语句的方法。</p>
<p>4.PreparedStatement接口</p>
<p>在实际开发中，如果涉及到向SQL语句传递参数，最好使用preparedStatement接口实现，不仅可以提高SQL的执行效率，而且还可以避免SQL的注入式攻击。</p>
<p>5.ResultSet接口</p>
<p>该接口位于java.sql包中，封装了数据查询的结果集。</p>
<h3 id="3-JDBC操作数据库"><a href="#3-JDBC操作数据库" class="headerlink" title="3.JDBC操作数据库"></a><em>3.JDBC操作数据库</em></h3><ul>
<li><p>添加数据</p>
</li>
<li><p>查询数据</p>
</li>
<li><p>修改数据</p>
</li>
<li><p>删除数据</p>
</li>
<li><p>批处理</p>
</li>
<li><p>调用存储过程</p>
<p>存储过程是一个SQL语句和可选控制流语句的预编译集合。在jdbc API中提供了调用存储过程的方法，通过CallableStatement对象进行操作。其调用方法：</p>
<p>{call《procedure-name》[(《arg1》,《arg2》,…)]},其中arg1,arg2为存储过程中的参数。</p>
</li>
</ul>
<h3 id="4-JDBC在Java-Web中的应用"><a href="#4-JDBC在Java-Web中的应用" class="headerlink" title="4.JDBC在Java Web中的应用"></a><em>4.JDBC在Java Web中的应用</em></h3><p>1.开发模式</p>
<p>MVC：该理念将软件分成三层：模型层(JavaBean)，视图层(JSP页面)，控制层(Servlet)</p>
<p>2.分页查询</p>
<p>通过ResultSet的光标实现分页</p>
<p>通过数据库机制进行分页</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/过滤器和监听器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/过滤器和监听器/" itemprop="url">过滤器和监听器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T21:42:07+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Sevlet过滤器"><a href="#1-Sevlet过滤器" class="headerlink" title="1.Sevlet过滤器"></a><em>1.Sevlet过滤器</em></h3><h4 id="1-什么是过滤器"><a href="#1-什么是过滤器" class="headerlink" title="1.什么是过滤器"></a>1.什么是过滤器</h4><p>servlet过滤器与servlet十分相似，但它具有拦截客户端请求的功能。</p>
<p>过滤器实质上是在web应用服务器上的web应用组件，用于拦截客户端资源与目标资源的请求。</p>
<h4 id="2-过滤器核心对象"><a href="#2-过滤器核心对象" class="headerlink" title="2.过滤器核心对象"></a>2.过滤器核心对象</h4><p>过滤器对象放置在javax.servlet包中。</p>
<ul>
<li><p>FilterConfig《interface》</p>
<p>该接口由servlet容器实现，主要用于获取过滤器中的配置信息。</p>
</li>
<li><p>Filter《interface》  </p>
<p>每个过滤对象都要直接或间接地实现Filter接口，在filter中定义了三个方法，分别是init(),doFilter(),destroy()方法。</p>
</li>
<li><p>FilterChain《interface》</p>
<p>该接口仍然由servlet容器实现。</p>
</li>
</ul>
<h4 id="3-过滤器的创建与配置"><a href="#3-过滤器的创建与配置" class="headerlink" title="3.过滤器的创建与配置"></a>3.过滤器的创建与配置</h4><p><strong>创建：</strong></p>
<p>创建一个过滤器对象需要实现Javax.servlet,Filter接口，同时实现Filter接口的三个方法。init():用于对过滤器的初始化进行处理。destroy():过滤器的销毁方法。</p>
<p>doFilter():用于过滤处理的业务逻辑。</p>
<p><strong>配置：</strong></p>
<p>《!–过滤器的声明–》</p>
<p>《filter》</p>
<p>《filter-name》MyFilter《/filter-name》</p>
<p>《filter-class》com.lyq.MyFilter《/filter-class》</p>
<p>《/filter》</p>
<p>《!–过滤器映射–》</p>
<p>《filter-mapping》</p>
<p>《filter-name》MyFilter《/filter-name》</p>
<p>《url-pattern》/MyFilter《/url-pattern》</p>
<p>《/filter-mapping》</p>
<h3 id="2-servlet监听器"><a href="#2-servlet监听器" class="headerlink" title="2.servlet监听器"></a><em>2.servlet监听器</em></h3><h4 id="1-servlet监听器简介"><a href="#1-servlet监听器简介" class="headerlink" title="1.servlet监听器简介"></a>1.servlet监听器简介</h4><p>监听器的作用是监听web容器中的有效事件，因此它是由容器管理的。</p>
<h4 id="2-servlet监听器的原理"><a href="#2-servlet监听器的原理" class="headerlink" title="2.servlet监听器的原理"></a>2.servlet监听器的原理</h4><p>servlet监听器是当今web开发的重要组成部分，它是在servlet2.3规范中和servlet过滤器一起引入的，并且在servlet2.4规范中进行较大的改进，主要用来对web应用进行监听和控制的，极大增强了web应用处理能力。</p>
<h4 id="3-servlet上下文监听"><a href="#3-servlet上下文监听" class="headerlink" title="3.servlet上下文监听"></a>3.servlet上下文监听</h4><p>servlet上下文监听可以监听servletContext对象的创建，删除以及属性的添加，删除和修改操作，该监听器需要用到如下两个接口。</p>
<p><strong>ServletContextListener接口</strong></p>
<p>该接口存放在javax.servlet包中，主要实现ServletContext的创建和删除。该接口提供了两个方法，也被称为“web应用程序的生命周期方法”</p>
<p>(1).contextInitialized(ServletContextEvent event)方法：通知正在收听的对象，应用程序已经被加载及初始化。</p>
<p>(2).contextDestroy(ServletContextEvent event)方法：通知正在收听的对象，应用程序已经被载出，即关闭。</p>
<p><strong>ServletContextAttributeListener接口</strong></p>
<p>该接口主要存放在javax.servlet包中，主要实现监听ServletContext属性的挺假，删除和修改。ServletContextAttributeListener接口提供了三个方法。</p>
<p>(1).attributeAdded(ServletContextAttributeEvent event)方法：当有对象加入到Application的范围时，通知正在收听的对象。</p>
<p>(2).attributeReplace(ServletContextAttributeEvent event)方法：当在application的范围中有对象取代另一个对象时，通知正在收听的对象。</p>
<p>(3).attributeRemove(ServletContextAttributeEvent event)方法：当有对象从application范围中移除时，通知正在收听的对象。</p>
<p><strong>创建监听器</strong>：</p>
<p>要让web容器启动时通知自定义的监听器，需要在web.xml中使用《listener》元素来配置监听器类。</p>
<p>eg:</p>
<p>《listener》</p>
<p>《listener-class》com.listener.MyContentListener《/listener-class》</p>
<p>《/listener》</p>
<h4 id="4-HTTP会话监听"><a href="#4-HTTP会话监听" class="headerlink" title="4.HTTP会话监听"></a>4.HTTP会话监听</h4><p>HTTP会话监听信息，有四个接口可以进行监听。</p>
<ul>
<li><p>HttpSessionListener接口</p>
<p>该接口实现HTTP会话的创建和销毁。该接口提供了以下两个方法：</p>
<p>(1).sessionCreated(HttpSessionEvent event)方法：通知正在收听的对象，session已经被加载及初始化。</p>
<p>(2).sessionDestroyed(HttpSessionEvent event)方法：通知正在收听的对象，session已经被载出。</p>
</li>
<li><p>HttpSessionActivationListener接口</p>
</li>
<li><p>该接口实现监听HTTP会话active和passivate。该接口提供了三个方法：</p>
<p>(1).attributeAdded(HttpSessionBindingEvent event)方法：当有对象加入到session的范围时，通知正在收听的对象。</p>
<p>(2).attributeReplaced(HttpSessionBindingEvent event)方法：当在session范围内有对象取代另一个对象时，通知正在收听的对象。</p>
<p>(3).attributeRemove(HttpSessionBindingEvent event)方法：当有对象从session范围在移除时，通知正在收听的对象。</p>
</li>
<li><p>HttpBindingListener接口</p>
<p>HttpBindingListener接口实现监听HTTP会话中对象的绑定信息。它是唯一不需要在web.xml中设定Listener的。该接口提供了以下两个方法。</p>
<p>(1).valueBound(HttpSessionBindingEvent event)方法：当有对象加入到session范围时会被自动调用。</p>
<p>(2).valueUnBound(HttpSessionBindingEvent event)方法：当有对象从session范围内移除时会被自动调用。</p>
</li>
<li><p>HttpSessionAttributeListener接口</p>
<p>该接口实现监听HTTP会话中属性的设置请求。</p>
<p>(1).sessionDidActivate(HttpSessionEvent event)方法：通知正在收听的对象，他的session已经变为有效状态。</p>
<p>(2).sessionWillPassivate(HttpSession event)方法：通知正在收听的对象，他的session已经变为无效状态。</p>
</li>
</ul>
<h4 id="5-servlet请求监听"><a href="#5-servlet请求监听" class="headerlink" title="5.servlet请求监听"></a>5.servlet请求监听</h4><ul>
<li><p>SevletRequestListener接口</p>
<p>该接口提供了以下两个方法：</p>
<p>(1).requestInitalized(ServletRequestEvent event)方法:通知正在收听的对象，ServletRequest已经被加载及初始化。</p>
<p>(2).requestDestroyed(ServletRequestEvent event)方法：通知正在收听的对象，ServletRequest对象已经被载出，即关闭。</p>
</li>
<li><p>ServletRequestAttributeListener接口</p>
<p>该接口提供了以下三个方法：</p>
<p>(1).attributeAdded(ServletRequestAttributeEvent event)方法：当有对象加入到request的范围时，通知正在收听的对象。</p>
<p>(2).attributeReplaced(ServletRequestAttributeEvent event)方法：当在request范围内有对象取代另一个对象时，通知正在收听的对象。</p>
<p>(3).attributeRemove(ServletRequestAttributeEvent event)方法：当有对象从request范围在移除时，通知正在收听的对象。</p>
</li>
</ul>
<h3 id="3-servlet3-0的新特性"><a href="#3-servlet3-0的新特性" class="headerlink" title="3.servlet3.0的新特性"></a><em>3.servlet3.0的新特性</em></h3><p>1.新增注释</p>
<ul>
<li><p>@WebServlet</p>
<p>eg:@WebServlet(name=”saveSErvlet” urlPatterns=”/SaveServlet”)</p>
</li>
<li><p>@WebFilter</p>
<p>eg:@WebFilter(filterName=”char”,urlPatterns=”/*”)</p>
</li>
<li><p>@WebListener</p>
<p>eg:@WebListener(“This is only a demo listener”)</p>
</li>
<li><p>@WebInitParam</p>
<p>eg:@WebServlet(urlPatterns=”/simple”,name=”SimpleServlet”,</p>
<p>initParam={@WebInitParam(name=”username”,value=”tom”)})</p>
</li>
</ul>
<p>2.对文件上传的支持</p>
<p>实现文件上传需要实现两件事：</p>
<p>需要添加@MultipartConfig注释</p>
<p>从request对象中获取Part文件对象</p>
<p>3.异步处理</p>
<p>在servlet3.0之前,一个servlet的工作流程是：首先，servlet接收到请求后，需要对请求携带的数据进行一些预处理。接着调用业务接口的某些方法，以完成业务处理。最后，根据处理的结果提交响应。</p>
<p>现在通过servlet3.0的异步处理机制可以将处理流程调整为以下流程：首先，servlet接收到请求后，需要对请求携带的数据进行一些预处理。接着servlet线程将请求转交给异步线程来执行业务处理，线程本身返回至容器。</p>
<p>这样，Servlet线程不在一直处于阻塞状态以等待业务逻辑的处理，而是启动异步后可以立即返回。</p>
<p>异步处理机制可应用于servlet和过滤器两种组件。@WebServlet和@WebFilter注释提供了asyncSupported属性，默认该属性的取值为false,要启动异步处理支持，只需将属性设置为true即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">佩琪</p>
              <p class="site-description motion-element" itemprop="description">JAVA</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">佩琪</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
