<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="JAVA">
<meta property="og:type" content="website">
<meta property="og:title" content="小猪佩琪">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小猪佩琪">
<meta property="og:description" content="JAVA">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小猪佩琪">
<meta name="twitter:description" content="JAVA">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>小猪佩琪</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小猪佩琪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小猪佩琪的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/29/了解JSP页面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/了解JSP页面/" itemprop="url">JSP基本语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T21:18:18+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-了解JSP页面"><a href="#1-了解JSP页面" class="headerlink" title="1.了解JSP页面"></a>1.了解JSP页面</h4><p>在一个JSP页面中，可以包括指令标识，HTML代码，JavaScript代码，嵌入的Java代码，注释和JSP动作标识等内容。</p>
<h4 id="2-指令标识"><a href="#2-指令标识" class="headerlink" title="2.指令标识"></a>2.指令标识</h4><p>1.定义：指令标识主要用于设定整个JSP页面范围内都有效的相关信息，它是被服务器解释执行的，不会产生任何内容输出到网页中。</p>
<p>2.语法格式：&lt;%@ 指令名 属性1=“属性值1” 属性2=“属性值2”……%&gt;</p>
<p>指令名：在JSP中包含page，include和taglib三条指令</p>
<ul>
<li><p>page指令</p>
<p>language属性：</p>
<p>用于设置JSP页面使用的语言，目前只支持Java。</p>
<p>extends属性：</p>
<p>用于设置JSP页面继承的Java类。</p>
<p>pageEncoding属性：</p>
<p>用于设置JSP页面的编码格式。</p>
<p>contentType属性：</p>
<p>用于设置JSP页面的MIME类型和字符编码。</p>
<p>session属性：</p>
<p>用于设置JSP页面是否使用HTTP的session会话对象。属性值是布尔型。</p>
<p>buffer属性：</p>
<p>用于设置JSP的out输出对象使用的缓冲区大小，默认为8kb，单位只能用kb。</p>
<p>import属性：</p>
<p>用于设置JSP页面导入的类包。</p>
<p>autoFlush属性：</p>
<p>用于设置JSP页面缓存满时，是否刷新缓存。默认为true。</p>
<p>isErrorPage属性：</p>
<p>可以将当前的JSP页面设置成错误处理页面来处理另一个JSP页面的错误，也就是异常处理。</p>
<p>errorPage属性：</p>
<p>用来指定处理当前JSP页面异常错误的另一个JSP页面。</p>
</li>
<li><p>include指令</p>
<p>通过该指令可以在一个JSP页面中包含另一个JSP页面。不过该指令是静态包含，即被包含文件中的所有内容会被原样包含到该JSP页面中。</p>
<p>语法格式:&lt;%@ include file=”path”%&gt;</p>
<p>只有file一个属性，用于指定包含文件的路径，该路径可以是相对路径，也可以是绝对路径。</p>
</li>
<li><p>taglib指令</p>
<p>通过该指令声明该页面中所使用的标签库，同事引用标签库，并指定标签的前缀。</p>
<p>语法格式：&lt;%@ taglib prefix=”c” uri=””%&gt;</p>
<p>prefix:用于指定标签的前缀。</p>
<p>uri:用于指定标签文件的存放位置。</p>
</li>
</ul>
<h4 id="3-脚本标识"><a href="#3-脚本标识" class="headerlink" title="3.脚本标识"></a>3.脚本标识</h4><p>1.JSP表达式</p>
<p>用于向页面中输出信息</p>
<p>语法格式：&lt;%= 表达式%&gt;</p>
<p>2.声明标识</p>
<p>用于在JSP页面中定义全局的变量和方法。</p>
<p>语法格式：&lt;%! 声明变量或方法的代码%&gt;</p>
<p>3.代码片段</p>
<p>就是在JSP页面中嵌入的Java代码或脚本代码。</p>
<p>语法格式：&lt;% Java代码或是脚本代码%&gt;</p>
<h4 id="4-JSP注释"><a href="#4-JSP注释" class="headerlink" title="4.JSP注释"></a>4.JSP注释</h4><p>1.单行注释</p>
<p>//注释内容</p>
<p>2.多行注释</p>
<p>/*</p>
<p>注释内容1</p>
<p>注释内容2</p>
<p>*/</p>
<p>或</p>
<p>/*</p>
<p> *注释内容1</p>
<p> *注释内容2</p>
<p>*/</p>
<p>3.提示文档注释</p>
<p>/**</p>
<p>提示信息1</p>
<p>提示信息2</p>
<p>*/</p>
<p>或</p>
<p>/**</p>
<p> *提示信息1</p>
<p> *提示信息2</p>
<p>*/</p>
<p>4.隐藏注释</p>
<p>这种注释不仅在浏览器中看不到，而且在HTML源代码中也看不到。</p>
<p>&lt;%- 注释内容 -%&gt;</p>
<p>5.动态注释</p>
<p>由于HTML注释对JSP嵌入的代码不起作用，因此可以利用他们的组合构成动态的HTML注释文本。</p>
<!-- <%=new Date()%> -->
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/27/算法总结（七）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/算法总结（七）/" itemprop="url">算法总结（七）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-27T09:41:45+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-序列化二叉树"><a href="#1-序列化二叉树" class="headerlink" title="1.序列化二叉树"></a>1.序列化二叉树</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<blockquote>
<p>分析:根据前序遍历规则完成序列化与反序列化。所谓序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</p>
<p>依据前序遍历序列来序列化二叉树，因为前序遍历序列是从根结点开始的。当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。</p>
<p>另外，结点之间的数值用逗号隔开.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">  int index=-1;</span><br><span class="line">	String Serialize(TreeNode root) &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		if (root == null) &#123;</span><br><span class="line">			sb.append(&quot;#,&quot;);</span><br><span class="line">			return sb.toString();</span><br><span class="line">		&#125;</span><br><span class="line">		sb.append(root.val+&quot;,&quot;);</span><br><span class="line">		sb.append(Serialize(root.left));</span><br><span class="line">		sb.append(Serialize(root.right));</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode Deserialize(String str) &#123;</span><br><span class="line">     String []s=str.split(&quot;,&quot;);</span><br><span class="line">     index++;</span><br><span class="line">     TreeNode node=null;</span><br><span class="line">     if(!s[index].equals(&quot;#&quot;)) &#123;</span><br><span class="line">    	 node=new TreeNode(Integer.valueOf(s[index]));</span><br><span class="line">    	 node.left=Deserialize(str);</span><br><span class="line">    	 node.right=Deserialize(str);</span><br><span class="line">     &#125;</span><br><span class="line">     return node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉搜索树的第k个结点"><a href="#2-二叉搜索树的第k个结点" class="headerlink" title="2.二叉搜索树的第k个结点"></a>2.二叉搜索树的第k个结点</h4><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<blockquote>
<p>分析：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。</p>
<p>  所以，按照中序遍历顺序找到第k个结点就是结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int index = 0; //计数器</span><br><span class="line">    TreeNode KthNode(TreeNode root, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root != null)&#123; //中序遍历寻找第k个</span><br><span class="line">            TreeNode node = KthNode(root.left,k);</span><br><span class="line">            if(node != null)</span><br><span class="line">                return node;</span><br><span class="line">            index ++;</span><br><span class="line">            if(index == k)</span><br><span class="line">                return root;</span><br><span class="line">            node = KthNode(root.right,k);</span><br><span class="line">            if(node != null)</span><br><span class="line">                return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-数据流中的中位数"><a href="#3-数据流中的中位数" class="headerlink" title="3.数据流中的中位数"></a>3.数据流中的中位数</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<blockquote>
<p>分析：利用两个PriorityQueue优先队列，一个栈A采用默认第一个是最小值，另一个栈B重写比较方法改为第一个是最大值。通过出入栈控制B中的数量大于栈A1个或0个。根据一共入栈的数量的奇偶数，分别计算出中位数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;();</span><br><span class="line">	PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line">			return o2 - o1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	public void Insert(Integer num) &#123;</span><br><span class="line">    if(q1.isEmpty()||num&lt;=q1.peek()) &#123;</span><br><span class="line">    	q1.add(num);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">    	q2.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    if(q1.size()+1==q2.size()) &#123;</span><br><span class="line">    	q1.add(q2.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    if(q1.size()==q2.size()+2) &#123;</span><br><span class="line">    	q2.add(q1.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Double GetMedian() &#123;</span><br><span class="line">        System.out.println(&quot;队列１&quot;+q1);</span><br><span class="line">		System.out.println(&quot;队列2&quot;+q2);</span><br><span class="line">       if(q1.size()==q2.size()) &#123;</span><br><span class="line">    	   return (q1.peek()+q2.peek())/2.0;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">    	   return  Double.valueOf(q1.peek())  ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/26/算法总结（六）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/算法总结（六）/" itemprop="url">算法总结（六）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-26T14:17:24+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-数组中重复的数字"><a href="#1-数组中重复的数字" class="headerlink" title="1.数组中重复的数字"></a>1.数组中重复的数字</h4><p> 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<blockquote>
<p>分析：常规做法：hashmap键值对保存数与次数，或利用set的唯一性保存数，若重复则返回fasle进而来返回重复的数字。</p>
<p>该题因为强调了数的大小范围，所以可以将数作为另一个布尔型数组（只占一字节）的下标，并给予标识，通过判断该下标下是否有该表示来判断是否重复。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean duplicate(int numbers[], int length, int[] duplication) &#123;</span><br><span class="line">       boolean[] k = new boolean[length];</span><br><span class="line">       for (int i = 0; i &lt; k.length; i++) &#123;</span><br><span class="line">           if (k[numbers[i]] == true) &#123;</span><br><span class="line">               duplication[0] = numbers[i];</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           k[numbers[i]] = true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="２．构建乘积数组"><a href="#２．构建乘积数组" class="headerlink" title="２．构建乘积数组"></a>２．构建乘积数组</h4><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。</p>
<blockquote>
<p>分析：B[i]可以看成是矩阵每行的乘积，先算下三角的连乘，在按照上三角的规律把另外一部分也乘进去。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] multiply(int[] A) &#123;</span><br><span class="line">        int length = A.length;</span><br><span class="line">        int[] B = new int[length];</span><br><span class="line">        if(length != 0 )&#123;</span><br><span class="line">            B[0] = 1;</span><br><span class="line">            //计算下三角连乘</span><br><span class="line">            for(int i = 1; i &lt; length; i++)&#123;</span><br><span class="line">                B[i] = B[i-1] * A[i-1];</span><br><span class="line">            &#125;</span><br><span class="line">            int temp = 1;</span><br><span class="line">            //计算上三角</span><br><span class="line">            for(int j = length-2; j &gt;= 0; j--)&#123;</span><br><span class="line">                temp *= A[j+1];</span><br><span class="line">                B[j] *= temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="３．表示数值的字符串"><a href="#３．表示数值的字符串" class="headerlink" title="３．表示数值的字符串"></a>３．表示数值的字符串</h4><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<blockquote>
<p>分析：</p>
<p>１．判断是否为有符号数：在基于当前字符是‘＋’｜｜‘－’的条件下，判断后续的数值是否为无符号整数。</p>
<p>２．判断是否为无符号整数：判段遍历当前及之后的字符是否为数值（‘０’～‘９’），下标++.若存在返回true,反之为fasle。</p>
<p>３．判断后续字符是否为‘.’,若是则判断后续字符是否为无符号数。注意”－．３“的正确性，即‘.’之前的无符号数为fasle，只要‘.’后的无符号数为true,则判断当前下标以前的标示为true.</p>
<p>４．判断后续字符是否为‘ｅ’或’E’,若是则判断后续字符是否为有符号数。</p>
<p>５．最后通过判断无符号数的返回值和是否遍历完字符串来判断该字符串是否表示数值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  private int index = 0;</span><br><span class="line">    public boolean isNumeric(char[] str) &#123;</span><br><span class="line"> if(str.length&lt;1)</span><br><span class="line">			return false;</span><br><span class="line">		boolean b=scanInteger(str);</span><br><span class="line">        if(index&lt;str.length&amp;&amp;str[index]==&apos;.&apos;) &#123;</span><br><span class="line">        	index++;</span><br><span class="line">        	b=scanUnsignedInteger(str)||b;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index&lt;str.length&amp;&amp;(str[index]==&apos;e&apos;||str[index]==&apos;E&apos;)) &#123;</span><br><span class="line">        	index++;</span><br><span class="line">        	b=b&amp;&amp;scanInteger(str);</span><br><span class="line">        &#125;</span><br><span class="line">		return b&amp;&amp;index==str.length;</span><br><span class="line">	&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断是否为有符号整数</span><br><span class="line"> * @param str</span><br><span class="line"> * @param index</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">	public boolean scanInteger(char[] str) &#123;</span><br><span class="line">        if(index&lt;str.length&amp;&amp;(str[index]==&apos;+&apos;||str[index]==&apos;-&apos;)) &#123;</span><br><span class="line">        	index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return scanUnsignedInteger(str);</span><br><span class="line">	&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断是否为无符号整数</span><br><span class="line"> * @param str</span><br><span class="line"> * @param index</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">	public boolean scanUnsignedInteger(char[] str) &#123;</span><br><span class="line">		int start=index;</span><br><span class="line">       while(index&lt;str.length&amp;&amp;str[index]&lt;=&apos;9&apos;&amp;&amp;str[index]&gt;=&apos;0&apos;) &#123;</span><br><span class="line">    	   index++;</span><br><span class="line">       &#125;</span><br><span class="line">       return index&gt;start;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-字符流中第一个不重复的字符"><a href="#4-字符流中第一个不重复的字符" class="headerlink" title="4.字符流中第一个不重复的字符"></a>4.字符流中第一个不重复的字符</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<blockquote>
<p>分析：利用map的键值对存储该数和该数出现的次数</p>
<p>注：１．以前用的判断是否包含键constainkey()的方法赋值为０或++,现在可以用map.getOrDefault（）来求出该键的值，若有该值则输出，若无则设为默认值。</p>
<p>２．遍历HashMap或Hashtable时不要求顺序输出，即与顺序无关．但可以用<strong>java.util.LinkedHashMap</strong> 就是按加入时的顺序遍历了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	public void Insert(char ch) &#123;</span><br><span class="line">       int c = map.getOrDefault(ch, 0);</span><br><span class="line">       map.put(ch, ++c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// return the first appearence once char in current stringstream</span><br><span class="line">	public char FirstAppearingOnce() &#123;</span><br><span class="line">       for(Character c:map.keySet()) &#123;</span><br><span class="line">    	   if(map.get(c)==1)</span><br><span class="line">    		   return c;</span><br><span class="line">       &#125;</span><br><span class="line">       return &apos;#&apos;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="５．链表中环的入口结点"><a href="#５．链表中环的入口结点" class="headerlink" title="５．链表中环的入口结点"></a>５．链表中环的入口结点</h4><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<blockquote>
<p>分析：</p>
<p>假设x为环前面的路程（黑色路程），a为环入口到相遇点的路程（蓝色路程，假设顺时针走）， c为环的长度（蓝色+橙色路程） </p>
<p>  当快慢指针相遇的时候： </p>
<p>  此时慢指针走的路程为Sslow =   x + m <em> c + a<br> 快指针走的路程为Sfast = x + n </em> c + a<br> 2 Sslow =   Sfast<br> 2 <em> ( x + m</em>c + a ) = (x + n <em>c + a)<br> 从而可以推导出：<br> x = (n   - 2 </em> m )<em>c - a<br> = (n - 2 </em>m -1 )*c + c - a<br> 即环前面的路程 =   数个环的长度（为可能为0） + c - a<br> 什么是c - a？这是相遇点后，环后面部分的路程。（橙色路程）<br>   所以，我们可以让一个指针从起点A开始走，让一个指针从相遇点B开始继续往后走，<br>   2个指针速度一样，那么，当从原点的指针走到环入口点的时候（此时刚好走了x）<br> 从相遇点开始走的那个指针也一定刚好到达环入口点。<br>   所以2者会相遇，且恰好相遇在环的入口点。 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public ListNode EntryNodeOfLoop(ListNode pHead)&#123;</span><br><span class="line">      if(pHead==null||pHead.next==null||pHead.next.next==null)&#123;</span><br><span class="line">    	   return null;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode fast=pHead.next.next;</span><br><span class="line">       ListNode slow=pHead.next;</span><br><span class="line">       while(fast!=slow) &#123;</span><br><span class="line">    	   if(fast.next!=null&amp;&amp;fast.next.next!=null) &#123;</span><br><span class="line">    		   fast=fast.next.next;</span><br><span class="line">    		   slow=slow.next;</span><br><span class="line">    	   &#125;else &#123;</span><br><span class="line">    		   return null;</span><br><span class="line">    	   &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //此时fast==slow</span><br><span class="line">       fast=pHead;</span><br><span class="line">       while(fast!=slow) &#123;</span><br><span class="line">    	   fast=fast.next;</span><br><span class="line">    	   slow=slow.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return fast;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="６．删除链表中重复的结点"><a href="#６．删除链表中重复的结点" class="headerlink" title="６．删除链表中重复的结点"></a>６．删除链表中重复的结点</h4><p> 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<blockquote>
<p>分析：递归法：</p>
<p>将参数phead当做当前节点普遍化。</p>
<p>1.phead与下一个节点重复，通过循环判断直到找到与之不重复的节点作为递归参数。</p>
<p>2.phead与下一个节点不重复，则通过递归继续判断phead下一个节点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode deleteDuplication(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line"> if(pHead==null||pHead.next==null)</span><br><span class="line">        	 return pHead;</span><br><span class="line">         if(pHead.val==pHead.next.val) &#123;</span><br><span class="line">        	ListNode node=pHead.next;</span><br><span class="line">        	while(node!=null&amp;&amp;node.val==pHead.val) &#123;</span><br><span class="line">        		node=node.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        	return deleteDuplication(node);</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">        	 pHead.next=deleteDuplication(pHead.next);</span><br><span class="line">        	 return pHead;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-二叉树的下一个结点"><a href="#7-二叉树的下一个结点" class="headerlink" title="7.二叉树的下一个结点"></a>7.二叉树的下一个结点</h4><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<blockquote>
<p>分析：</p>
<p>1.二叉树为空，则返回空； </p>
<p>2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点； </p>
<p>3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">    &#123;</span><br><span class="line">      if (pNode == null)</span><br><span class="line">			return null;</span><br><span class="line">		// 若右子树存在</span><br><span class="line">		if (pNode.right != null) &#123;</span><br><span class="line">			pNode = pNode.right;</span><br><span class="line">			while (pNode.left != null) &#123;</span><br><span class="line">				pNode = pNode.left;</span><br><span class="line">			&#125;</span><br><span class="line">			return pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		//右子树不存在</span><br><span class="line">		else &#123;</span><br><span class="line">			while(pNode.next!=null) &#123;</span><br><span class="line">				if(pNode.next.left==pNode) &#123;</span><br><span class="line">					return pNode.next;</span><br><span class="line">				&#125;</span><br><span class="line">				pNode=pNode.next;</span><br><span class="line">			&#125;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-对称的二叉树"><a href="#8-对称的二叉树" class="headerlink" title="8.对称的二叉树"></a>8.对称的二叉树</h4><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<blockquote>
<p>分析：首先根节点与左右节点，左子树的右节点与右子树的左子树相同，左子树的左节点与右子树的右节点相同，采用递归即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   boolean isSymmetrical(TreeNode pRoot) &#123;</span><br><span class="line">		if (pRoot == null)</span><br><span class="line">			return true;</span><br><span class="line">		else</span><br><span class="line">			return ff(pRoot.left,pRoot.right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean ff(TreeNode left,TreeNode right) &#123;</span><br><span class="line">      if(left==null&amp;&amp;right==null)</span><br><span class="line">    	  return true;</span><br><span class="line">      if(left!=null&amp;&amp;right!=null) &#123;</span><br><span class="line">    	  return left.val==right.val&amp;&amp;ff(left.left, right.right)&amp;&amp;ff(left.right,right.left);</span><br><span class="line">      &#125;</span><br><span class="line">      return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-按之字形顺序打印二叉树"><a href="#9-按之字形顺序打印二叉树" class="headerlink" title="9.按之字形顺序打印二叉树"></a>9.按之字形顺序打印二叉树</h4><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<blockquote>
<p>分析：利用两个栈分别存放奇偶层的元素，遍历逐个出栈每层的元素，并将其左右节点入栈到另一个栈。直至两个栈为空。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Stack;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">int c=1;</span><br><span class="line">		Stack&lt;TreeNode&gt; stack1=new Stack&lt;&gt;();</span><br><span class="line">		Stack&lt;TreeNode&gt; stack2=new Stack&lt;&gt;();</span><br><span class="line">		ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">		stack1.push(pRoot);</span><br><span class="line">		while(!stack1.isEmpty()||!stack2.isEmpty()) &#123;</span><br><span class="line">			if(c%2!=0) &#123;</span><br><span class="line">				ArrayList&lt;Integer&gt; list1=new ArrayList&lt;&gt;();</span><br><span class="line">				while(!stack1.isEmpty()) &#123;</span><br><span class="line">				TreeNode node=stack1.pop();</span><br><span class="line">				if(node!=null) &#123;</span><br><span class="line">					System.out.print(node.val+&quot; &quot;);</span><br><span class="line">					list1.add(node.val);</span><br><span class="line">					stack2.push(node.left);</span><br><span class="line">					stack2.push(node.right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				if(!list1.isEmpty()) &#123;</span><br><span class="line">						list.add(list1);</span><br><span class="line">						c++;</span><br><span class="line">						System.out.println();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				ArrayList&lt;Integer&gt; list2=new ArrayList&lt;&gt;();</span><br><span class="line">				while(!stack2.isEmpty()) &#123;</span><br><span class="line">				TreeNode node1=stack2.pop();</span><br><span class="line">				if(node1!=null) &#123;</span><br><span class="line">					System.out.print(node1.val);</span><br><span class="line">					list2.add(node1.val);</span><br><span class="line">					stack1.push(node1.right);</span><br><span class="line">					stack1.push(node1.left);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				if(!list2.isEmpty()) &#123;</span><br><span class="line">					list.add(list2);</span><br><span class="line">					c++;</span><br><span class="line">					System.out.println();</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-把二叉树打印成多行"><a href="#10-把二叉树打印成多行" class="headerlink" title="10.把二叉树打印成多行"></a>10.把二叉树打印成多行</h4><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<blockquote>
<p>分析：与上题大同小异，但输出顺序不同，所以用到的是两个队列来存放奇偶层节点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Stack;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">      ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">	 int c=1;</span><br><span class="line">			Queue&lt;TreeNode&gt; queue1=new LinkedList&lt;&gt;();</span><br><span class="line">			Queue&lt;TreeNode&gt; queue2=new LinkedList&lt;&gt;();</span><br><span class="line">			ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">			queue1.add(pRoot);</span><br><span class="line">			while(!queue1.isEmpty()||!queue2.isEmpty()) &#123;</span><br><span class="line">				if(c%2!=0) &#123;</span><br><span class="line">					ArrayList&lt;Integer&gt; list1=new ArrayList&lt;&gt;();</span><br><span class="line">					while(!queue1.isEmpty()) &#123;</span><br><span class="line">					TreeNode node=queue1.poll();</span><br><span class="line">					if(node!=null) &#123;</span><br><span class="line">						System.out.print(node.val+&quot; &quot;);</span><br><span class="line">						list1.add(node.val);</span><br><span class="line">						if(node.left!=null) &#123;</span><br><span class="line">						queue2.add(node.left);</span><br><span class="line">						&#125;</span><br><span class="line">						if(node.right!=null) &#123;</span><br><span class="line">						queue2.add(node.right);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">					if(!list1.isEmpty()) &#123;</span><br><span class="line">							list.add(list1);</span><br><span class="line">							c++;</span><br><span class="line">							System.out.println();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">					ArrayList&lt;Integer&gt; list2=new ArrayList&lt;&gt;();</span><br><span class="line">					while(!queue2.isEmpty()) &#123;</span><br><span class="line">					TreeNode node1=queue2.poll();</span><br><span class="line">					if(node1!=null) &#123;</span><br><span class="line">						System.out.print(node1.val+&quot; &quot;);</span><br><span class="line">						list2.add(node1.val);</span><br><span class="line">						queue1.add(node1.left);</span><br><span class="line">						queue1.add(node1.right);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">					if(!list2.isEmpty()) &#123;</span><br><span class="line">						list.add(list2);</span><br><span class="line">						c++;</span><br><span class="line">						System.out.println();</span><br><span class="line">				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return list;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/算法总结（五）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/算法总结（五）/" itemprop="url">算法总结（五）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-25T21:40:14+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-数组中只出现一次的数字"><a href="#1-数组中只出现一次的数字" class="headerlink" title="1.数组中只出现一次的数字"></a>1.数组中只出现一次的数字</h4><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<blockquote>
<p>分析：位运算中的异或运算：相同的数异或为０，０与任何数异或为其本身。</p>
<p>由题意可得：因有偶数个相同的数，则他们异或的结果为０，那么所有数异或的结果为特定的两个数异或的结果。</p>
<p>所以：１．先求出所有的数的异或结果。</p>
<p>２．再找结果中结果中第一个１的位置，循环判断在该位的值是否为１，将其分成两派，将这两派异或的结果分别为特定的两个数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2)    &#123;</span><br><span class="line">        int length = array.length;</span><br><span class="line">        if(length == 2)&#123;</span><br><span class="line">            num1[0] = array[0];</span><br><span class="line">            num2[0] = array[1];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int bitResult = 0;</span><br><span class="line">        for(int i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">            bitResult ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int index = findFirst1(bitResult);</span><br><span class="line">        for(int i = 0; i &lt; length; ++i)&#123;</span><br><span class="line">            if(isBit1(array[i], index))&#123;</span><br><span class="line">                num1[0] ^= array[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                num2[0] ^= array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private int findFirst1(int bitResult)&#123;</span><br><span class="line">        int index = 0;</span><br><span class="line">        while(((bitResult &amp; 1) == 0) &amp;&amp; index &lt; 32)&#123;</span><br><span class="line">            bitResult &gt;&gt;= 1;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private boolean isBit1(int target, int index)&#123;</span><br><span class="line">        return ((target &gt;&gt; index) &amp; 1) == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="２．和为S的连续正数序列"><a href="#２．和为S的连续正数序列" class="headerlink" title="２．和为S的连续正数序列"></a>２．和为S的连续正数序列</h4><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<blockquote>
<p>分析：等差数列求和的问题：</p>
<p>１．确定数列长度ｎ的范围，即为２&lt;n&lt;根号下（２×ｓｕｍ）</p>
<p>2.在ｎ的范围内确定ｎ的大小，若ｎ为奇数：ｎ&amp;1==1&amp;&amp;sum%n==0</p>
<p>若ｎ为偶数：(sum%n)*2==n.</p>
<p>3.根据首项，和序列长度n的大小，确定该序列。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int n = (int) Math.sqrt(2 * sum); n &gt;= 2; n--) &#123;</span><br><span class="line">            if ((n &amp; 1) == 1 &amp;&amp; sum % n == 0 || (sum % n) * 2 == n) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                for (int j = 0, k = (sum / n) - (n - 1) / 2; j &lt; n; j++, k++) &#123;</span><br><span class="line">                    list.add(k);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="３．和为S的两个数字"><a href="#３．和为S的两个数字" class="headerlink" title="３．和为S的两个数字"></a>３．和为S的两个数字</h4><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<blockquote>
<p>分析：对于已经排序的数组，两端的乘积最小，所以将指针指向数组首项和尾项，根据他们之和的大小，再将首尾指针移动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">		 int i=0,j=array.length-1;</span><br><span class="line">		 while(i&lt;j) &#123;</span><br><span class="line">			 int sum1=array[i]+array[j];</span><br><span class="line">			 if(sum1==sum) &#123;</span><br><span class="line">				 list.add(array[i]);</span><br><span class="line">				 list.add(array[j]);</span><br><span class="line">				 break;</span><br><span class="line">			 &#125;</span><br><span class="line">			 if(sum1&gt;sum) &#123;</span><br><span class="line">				 j--;</span><br><span class="line">			 &#125;</span><br><span class="line">			 else &#123;</span><br><span class="line">				 i++;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="４．左旋转字符串"><a href="#４．左旋转字符串" class="headerlink" title="４．左旋转字符串"></a>４．左旋转字符串</h4><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<blockquote>
<p>分析：字符串的翻转问题：</p>
<p>XY-&gt;(XTYT)T-&gt;YX</p>
<p>即翻转三次。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String LeftRotateString(String str,int n) &#123;</span><br><span class="line">        char[] chars = str.toCharArray();        </span><br><span class="line">        if(chars.length &lt; n) return &quot;&quot;;</span><br><span class="line">        reverse(chars, 0, n-1);</span><br><span class="line">        reverse(chars, n, chars.length-1);</span><br><span class="line">        reverse(chars, 0, chars.length-1);</span><br><span class="line">        StringBuilder sb = new StringBuilder(chars.length);</span><br><span class="line">        for(char c:chars)&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public void reverse(char[] chars,int low,int high)&#123;</span><br><span class="line">        char temp;</span><br><span class="line">        while(low&lt;high)&#123;</span><br><span class="line">            temp = chars[low];</span><br><span class="line">            chars[low] = chars[high];</span><br><span class="line">            chars[high] = temp;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-翻转单词顺序列"><a href="#5-翻转单词顺序列" class="headerlink" title="5.翻转单词顺序列"></a>5.翻转单词顺序列</h4><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<blockquote>
<p>分析：字符串的翻转，利用while循环将数组一首一尾元素交换，并将指针向前推进。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public String ReverseSentence(String str) &#123;</span><br><span class="line">　　　　　if(str.trim().equals(&quot;&quot;))&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;</span><br><span class="line">		String s[] = str.split(&quot; &quot;);</span><br><span class="line">		String s1 = &quot;&quot;;</span><br><span class="line">		StringBuilder s2=new StringBuilder();</span><br><span class="line">		int i = 0, j = s.length - 1;</span><br><span class="line">		while (j &gt; i) &#123;</span><br><span class="line">			String temp = s[i];</span><br><span class="line">			s[i] = s[j];</span><br><span class="line">			s[j] = temp;</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		for (String string : s) &#123;</span><br><span class="line">//			s1 = s1 +&quot; &quot;+ string;</span><br><span class="line">			s2.append(&quot; &quot;+string);</span><br><span class="line">		&#125;</span><br><span class="line">//		return s1.substring(1);</span><br><span class="line">		return s2.toString().substring(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="６．扑克牌顺子"><a href="#６．扑克牌顺子" class="headerlink" title="６．扑克牌顺子"></a>６．扑克牌顺子</h4><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p>
<blockquote>
<p>分析：１．计算０的数量。</p>
<p>２．判断排序后的前后元素是否相等，相等则返回false。</p>
<p>３．不相等则计算排序后的总间隔数。</p>
<p>４．比较０的数量是否等于总间隔数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean isContinuous(int [] numbers) &#123;</span><br><span class="line">        if(numbers.length==0)</span><br><span class="line">			return false;</span><br><span class="line">int count =0;</span><br><span class="line">		int count1=0;</span><br><span class="line">		ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">       for(int i=0;i&lt;numbers.length;i++) &#123;</span><br><span class="line">    	   if(numbers[i]==0) &#123;</span><br><span class="line">    		   ++count;</span><br><span class="line">    		   System.out.println(&quot;count=&quot;+count);</span><br><span class="line">    	   &#125;</span><br><span class="line">    	   else</span><br><span class="line">    		   list.add(numbers[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(list);</span><br><span class="line">    	   for(int i=0;i&lt;list.size()-1;i++) &#123;</span><br><span class="line">    		    if(list.get(i)==list.get(i+1))</span><br><span class="line">    			   return false;</span><br><span class="line">    		   count1=count1+list.get(i+1)-list.get(i)-1;</span><br><span class="line">    	   &#125;</span><br><span class="line">    	   if(count1&lt;=count)</span><br><span class="line">    		   return true;</span><br><span class="line">    	   else</span><br><span class="line">    		   return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="７．孩子们的游戏-圆圈中最后剩下的数"><a href="#７．孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="７．孩子们的游戏(圆圈中最后剩下的数)"></a>７．孩子们的游戏(圆圈中最后剩下的数)</h4><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<blockquote>
<p>分析：循环圈的报数：求余法</p>
<p>将所有编号为n的孩子加入队列，通过while循环通过求余，删除队列中序号为余数的值，直至队列的大小等于１，若最终返回值为１，即为所求，否则返回－１．</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"> public int LastRemaining_Solution(int n, int m) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; n; i ++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        int bt = 0;</span><br><span class="line">        while (list.size() &gt; 1) &#123;</span><br><span class="line">            bt = (bt + m - 1) % list.size();</span><br><span class="line">            list.remove(bt);</span><br><span class="line">        &#125;</span><br><span class="line">        return list.size() == 1 ? list.get(0) : -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="８．求1-2-3-…-n"><a href="#８．求1-2-3-…-n" class="headerlink" title="８．求1+2+3+…+n"></a>８．求1+2+3+…+n</h4><p> 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<blockquote>
<p>分析：利用&amp;&amp;短路作为递归的终结条件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Sum_Solution(int n) &#123;</span><br><span class="line">          int sum=n;</span><br><span class="line">      boolean b=(sum&gt;0)&amp;&amp;((sum+=Sum_Solution(n-1))&gt;0);</span><br><span class="line">      return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="９．不用加减乘除做加法"><a href="#９．不用加减乘除做加法" class="headerlink" title="９．不用加减乘除做加法"></a>９．不用加减乘除做加法</h4><p> 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<blockquote>
<p>分析：１．利用异或求出各位不算进位的值</p>
<p>２．利用与＆求出进位的值，并左移。</p>
<p>３．循环１）２），循环条件为直至２）为０。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Add(int num1,int num2) &#123;</span><br><span class="line">         while(num1!=0) &#123;</span><br><span class="line">	        int temp=num1^num2;</span><br><span class="line">	        num1=(num1&amp;num2)&lt;&lt;1;</span><br><span class="line">	        num2=temp;</span><br><span class="line">		  &#125;</span><br><span class="line">		  return num2;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="１０．把字符串转换成整数"><a href="#１０．把字符串转换成整数" class="headerlink" title="１０．把字符串转换成整数"></a>１０．把字符串转换成整数</h4><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
<blockquote>
<p>分析：循环便利字符串转的字符数组，若为＋，那么继续，若为－，则标志记录，</p>
<p>若不为０－９的字符，直接返回ｆａｌｓｅ。若为则利用ｓｕｍ值逐个求和。最后如果标志位表示负，则ｓｕｍ的相反数即为所求。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int StrToInt(String str) &#123;</span><br><span class="line">       char[] c=str.toCharArray();</span><br><span class="line">        int sum=0;</span><br><span class="line">        boolean b=false;</span><br><span class="line">        for(int i=0;i&lt;c.length;i++) &#123;</span><br><span class="line">        	System.out.println(&quot;c[i]=&quot;+c[i]);</span><br><span class="line">        	if(c[i]==&apos;+&apos;&amp;&amp;i==0) &#123;</span><br><span class="line">        		continue;</span><br><span class="line">        	&#125;</span><br><span class="line">        	else if(c[i]==&apos;-&apos;&amp;&amp;i==0) &#123;</span><br><span class="line">        		System.out.println(111);</span><br><span class="line">        		b=true;</span><br><span class="line">        		continue;</span><br><span class="line">        	&#125;</span><br><span class="line">        	else if(&apos;1&apos;&lt;=c[i]&amp;&amp;c[i]&lt;=&apos;9&apos;) &#123;</span><br><span class="line">        	int j=c[i]-&apos;0&apos;;</span><br><span class="line">        	sum=sum*10+j;</span><br><span class="line">        	&#125;</span><br><span class="line">        	else &#123;</span><br><span class="line">        		System.out.println(222);</span><br><span class="line">        		return 0;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b==true)</span><br><span class="line">        	return 0-sum;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/24/算法总结（四）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/算法总结（四）/" itemprop="url">算法总结（四）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-24T09:06:52+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-最小的K个数"><a href="#1-最小的K个数" class="headerlink" title="1.最小的K个数"></a>1.最小的K个数</h4><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<blockquote>
<p>分析：利用基于堆的优先队列，利用循环将输入的前ｋ个数字保存到优先队列中，然后将k个数字之后的数字依次与堆顶比较，若堆顶大于该数字，则移除，将该数字加入堆中。（PriorityQueue入队并不是 <strong>按顺序的</strong>，而在poll出来的时候是按顺序出队的）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">   public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">       int length = input.length;</span><br><span class="line">       if(k &gt; length || k == 0)&#123;</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(k, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                return o2.compareTo(o1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            if (maxHeap.size() != k) &#123;</span><br><span class="line">                maxHeap.offer(input[i]);</span><br><span class="line">            &#125; else if (maxHeap.peek() &gt; input[i]) &#123;</span><br><span class="line">                Integer temp = maxHeap.poll();</span><br><span class="line">                temp = null;</span><br><span class="line">                maxHeap.offer(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Integer integer : maxHeap) &#123;</span><br><span class="line">            result.add(integer);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="２．连续子数组的最大和"><a href="#２．连续子数组的最大和" class="headerlink" title="２．连续子数组的最大和"></a>２．连续子数组的最大和</h4><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<blockquote>
<p>分析：动态规划：动态规划<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">算法</a>是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public  int FindGreatestSumOfSubArray(int[] array) &#123;</span><br><span class="line">        int res = array[0]; //记录当前所有子数组的和的最大值</span><br><span class="line">        int max=array[0];   //包含array[i]的连续数组最大值</span><br><span class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</span><br><span class="line">            max=Math.max(max+array[i], array[i]);</span><br><span class="line">            res=Math.max(max, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="３．整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#３．整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="３．整数中1出现的次数（从1到n整数中1出现的次数）"></a>３．整数中1出现的次数（从1到n整数中1出现的次数）</h4><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p>
<blockquote>
<p>分析：暴力求解</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int NumberOf1Between1AndN_Solution(int n) &#123;</span><br><span class="line">	    int count=0;</span><br><span class="line">	    for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">	    	int temp=i;</span><br><span class="line">	    	while(temp&gt;0) &#123;</span><br><span class="line">	    		if(temp%10==1)</span><br><span class="line">	    			count++;</span><br><span class="line">	    		temp=temp/10;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="４．把数组排成最小的数"><a href="#４．把数组排成最小的数" class="headerlink" title="４．把数组排成最小的数"></a>４．把数组排成最小的数</h4><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<blockquote>
<p>分析:通过重写Arrays.sort(String a[],Comparator)中的匿名函数compare的排序方式，比较(o1+o2).compareTo(o2+o1)的大小，来调整他们之间的顺序。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> public String PrintMinNumber(int[] numbers) &#123;</span><br><span class="line">	if(numbers==null||numbers.length==0)</span><br><span class="line">		return &quot;&quot;;</span><br><span class="line">	StringBuilder s=new StringBuilder();</span><br><span class="line">	String array[]=new String [numbers.length];</span><br><span class="line">	for(int i=0;i&lt;numbers.length;i++) &#123;</span><br><span class="line">		array[i]=String.valueOf(numbers[i]);//将整型数组转为String数组</span><br><span class="line">		Arrays.sort(array, new Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public int compare(String o1, String o2) &#123;</span><br><span class="line">				String s1=o1+o2;</span><br><span class="line">				String s2=o2+o1;</span><br><span class="line">				return s1.compareTo(s2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	for (String string : array) &#123;</span><br><span class="line">		s.append(string);</span><br><span class="line">	&#125;</span><br><span class="line">	return s.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="５．第一个只出现一次的字符"><a href="#５．第一个只出现一次的字符" class="headerlink" title="５．第一个只出现一次的字符"></a>５．第一个只出现一次的字符</h4><p> 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<blockquote>
<p>分析：利用map的键值对来存储。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int FirstNotRepeatingChar(String str) &#123;</span><br><span class="line">	   char a[]=str.toCharArray();</span><br><span class="line">	 ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">	 ArrayList&lt;Character&gt; list1=new ArrayList&lt;&gt;();</span><br><span class="line">	Map&lt;Character, Integer&gt; map =new HashMap&lt;&gt;();</span><br><span class="line">	for(int i=0;i&lt;a.length;i++) &#123;</span><br><span class="line">		if(!map.containsKey(a[i])) &#123;</span><br><span class="line">			map.put(a[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			list1.add(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	for (Character character : list1) &#123;</span><br><span class="line">		map.remove(character);</span><br><span class="line">	&#125;</span><br><span class="line">	if(!map.isEmpty()) &#123;</span><br><span class="line">	for(Character s:map.keySet())&#123;</span><br><span class="line">           System.out.println(&quot;key : &quot;+s+&quot; value : &quot;+map.get(s));</span><br><span class="line">           list.add(map.get(s));</span><br><span class="line">    &#125;</span><br><span class="line">	Collections.sort(list);</span><br><span class="line">	  return list.get(0);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="６．数组中的逆序对"><a href="#６．数组中的逆序对" class="headerlink" title="６．数组中的逆序对"></a>６．数组中的逆序对</h4><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<blockquote>
<p>分析：并归排序－－分治思想</p>
<p>分：mergeSortUp2Down(a,start,mid);</p>
<p>mergeSortUp2Down(a,mid+1,end);</p>
<p>递归，将整体通过递归分成单个个体，终结条件为start&gt;=end</p>
<p>治：merge(a,start,mid,end)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    int sum ;</span><br><span class="line">	public int InversePairs(int[] array) &#123;</span><br><span class="line">		sum=0;</span><br><span class="line">		if(array!=null)</span><br><span class="line">         mergeSortUp2Down(array, 0, array.length-1);</span><br><span class="line">		return sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 并归排序</span><br><span class="line">	 * </span><br><span class="line">	 * @param array</span><br><span class="line">	 * @return</span><br><span class="line">	 */</span><br><span class="line">	public void mergeSortUp2Down(int a[], int start, int end) &#123;</span><br><span class="line">		if(start&gt;=end)</span><br><span class="line">			return;</span><br><span class="line">		int mid = (start + end) &gt;&gt; 1;</span><br><span class="line">		mergeSortUp2Down(a,start,mid);</span><br><span class="line">		mergeSortUp2Down(a, mid+1, end);</span><br><span class="line">		merge(a,start,mid,end);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void merge(int a[], int start, int mid, int end) &#123;</span><br><span class="line">      int b[]=new int[end - start + 1];</span><br><span class="line">      int i=start,j=mid+1,k=0;</span><br><span class="line">      while(i&lt;=mid&amp;&amp;j&lt;=end) &#123;</span><br><span class="line">    	  if(a[i]&lt;=a[j])</span><br><span class="line">    		  b[k++]=a[i++];</span><br><span class="line">    	  else&#123;</span><br><span class="line">    		  b[k++]=a[j++];</span><br><span class="line">    		  sum += mid - i + 1;</span><br><span class="line">              sum=sum%1000000007;</span><br><span class="line">    	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      while(i&lt;=mid) </span><br><span class="line">    	  b[k++]=a[i++];</span><br><span class="line">      while(j&lt;=end)</span><br><span class="line">    	  b[k++]=a[j++];</span><br><span class="line">      for(k=0;k&lt;b.length;k++) &#123;</span><br><span class="line">    	  a[start+k]=b[k];</span><br><span class="line">      &#125; </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-两个链表的第一个公共结点"><a href="#7-两个链表的第一个公共结点" class="headerlink" title="7.两个链表的第一个公共结点"></a>7.两个链表的第一个公共结点</h4><p>输入两个链表，找出它们的第一个公共结点。</p>
<blockquote>
<p>分析：将两个链表分别存放在两个栈中（利用栈先进后出的特征即栈顶都是公共节点）循环判断栈Ａ与栈Ｂ在不为空且栈顶一致的条件下，则两端同时出栈，并将出栈的节点保存，直至节点不一致，则此时保存的节点即为第一个公共节点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123;</span><br><span class="line"> if(pHead1==null||pHead2==null)</span><br><span class="line">			 return null;</span><br><span class="line">		 Stack&lt;ListNode&gt; stack1=new Stack&lt;&gt;();</span><br><span class="line">		 Stack&lt;ListNode&gt; stack2=new Stack&lt;&gt;();</span><br><span class="line">		 while(pHead1!=null) &#123;</span><br><span class="line">			 stack1.push(pHead1);</span><br><span class="line">			 pHead1=pHead1.next;</span><br><span class="line">		 &#125;</span><br><span class="line">		 while(pHead2!=null) &#123;</span><br><span class="line">			 stack2.push(pHead2);</span><br><span class="line">			 pHead2=pHead2.next;</span><br><span class="line">		 &#125;</span><br><span class="line">		 ListNode commenNode=null;</span><br><span class="line">		 while(!stack1.isEmpty()&amp;&amp;!stack2.isEmpty()&amp;&amp;stack1.peek()==stack2.peek()) &#123;</span><br><span class="line">			 stack1.pop();</span><br><span class="line">			 commenNode=stack2.pop();</span><br><span class="line">		 &#125;</span><br><span class="line">		 return commenNode;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="８．数字在排序数组中出现的次数"><a href="#８．数字在排序数组中出现的次数" class="headerlink" title="８．数字在排序数组中出现的次数"></a>８．数字在排序数组中出现的次数</h4><p>统计一个数字在排序数组中出现的次数。</p>
<p>分析：二分查找：递归版和循环版</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"> public int GetNumberOfK(int [] array , int k) &#123;</span><br><span class="line">        int length = array.length;</span><br><span class="line">        if(length == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int firstK = getFirstK(array, k, 0, length-1);</span><br><span class="line">        int lastK = getLastK(array, k, 0, length-1);</span><br><span class="line">        if(firstK != -1 &amp;&amp; lastK != -1)&#123;</span><br><span class="line">             return lastK - firstK + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //递归写法</span><br><span class="line">    private int getFirstK(int [] array , int k, int start, int end)&#123;</span><br><span class="line">        if(start &gt; end)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (start + end) &gt;&gt; 1;</span><br><span class="line">        if(array[mid] &gt; k)&#123;</span><br><span class="line">            return getFirstK(array, k, start, mid-1);</span><br><span class="line">        &#125;else if (array[mid] &lt; k)&#123;</span><br><span class="line">            return getFirstK(array, k, mid+1, end);</span><br><span class="line">        &#125;else if(mid-1 &gt;=0 &amp;&amp; array[mid-1] == k)&#123;</span><br><span class="line">            return getFirstK(array, k, start, mid-1);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //循环写法</span><br><span class="line">    private int getLastK(int [] array , int k, int start, int end)&#123;</span><br><span class="line">        int length = array.length;</span><br><span class="line">        int mid = (start + end) &gt;&gt; 1;</span><br><span class="line">        while(start &lt;= end)&#123;</span><br><span class="line">            if(array[mid] &gt; k)&#123;</span><br><span class="line">                end = mid-1;</span><br><span class="line">            &#125;else if(array[mid] &lt; k)&#123;</span><br><span class="line">                start = mid+1;</span><br><span class="line">            &#125;else if(mid+1 &lt; length &amp;&amp; array[mid+1] == k)&#123;</span><br><span class="line">                start = mid+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (start + end) &gt;&gt; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="９．二叉树的深度"><a href="#９．二叉树的深度" class="headerlink" title="９．二叉树的深度"></a>９．二叉树的深度</h4><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<blockquote>
<p>分析：递归法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int TreeDepth(TreeNode root) &#123;</span><br><span class="line">		if (root == null)</span><br><span class="line">			return 0;</span><br><span class="line">		int left = TreeDepth(root.left);</span><br><span class="line">		int right = TreeDepth(root.right);</span><br><span class="line">		return 1 + Math.max(left, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="１０．平衡二叉树"><a href="#１０．平衡二叉树" class="headerlink" title="１０．平衡二叉树"></a>１０．平衡二叉树</h4><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<blockquote>
<p>分析：借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   public boolean IsBalanced_Solution(TreeNode root) &#123;</span><br><span class="line">	return depth(root)!=-1;</span><br><span class="line">&#125;</span><br><span class="line">public int depth(TreeNode root) &#123;</span><br><span class="line">	if(root==null)</span><br><span class="line">		return 0;</span><br><span class="line">	int left=depth(root.left);</span><br><span class="line">	if(left==-1)return -1;</span><br><span class="line">	int right=depth(root.right);</span><br><span class="line">	if(right==-1)return -1;</span><br><span class="line">	return Math.abs(left-right)&gt;1?-1:1+Math.max(left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/算法总结（三）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/算法总结（三）/" itemprop="url">算法总结（三）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-23T09:03:51+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-合并两个排序的链表"><a href="#1-合并两个排序的链表" class="headerlink" title="1.合并两个排序的链表"></a>1.合并两个排序的链表</h4><p> 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<blockquote>
<p>分析：递归三大条件：终结条件（用if，返回特定情况下的值），递归前后的关系体现在参数的不同，返回值</p>
<p>链表合并的重点是重新建立listnode之间的next的关系。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ListNode Merge(ListNode list1,ListNode list2) &#123;</span><br><span class="line">       if(list1 == null)&#123;</span><br><span class="line">           return list2;</span><br><span class="line">       &#125;</span><br><span class="line">       if(list2 == null)&#123;</span><br><span class="line">           return list1;</span><br><span class="line">       &#125;</span><br><span class="line">       if(list1.val &lt;= list2.val)&#123;</span><br><span class="line">           list1.next = Merge(list1.next, list2);</span><br><span class="line">           return list1;</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           list2.next = Merge(list1, list2.next);</span><br><span class="line">           return list2;</span><br><span class="line">       &#125;       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="２．树的子结构"><a href="#２．树的子结构" class="headerlink" title="２．树的子结构"></a>２．树的子结构</h4><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<blockquote>
<p>分析：1、首先设置标志位result = false，因为一旦匹配成功result就设为true，</p>
<p>剩下的代码不会执行，如果匹配不成功，默认返回false</p>
<p>2、递归思想，如果根节点相同则递归调用DoesTree1HaveTree2（），</p>
<p>如果根节点不相同，则判断tree1的左子树和tree2是否相同，</p>
<p>再判断右子树和tree2是否相同</p>
<p>3、注意null的条件，HasSubTree中，如果两棵树都不为空才进行判断，</p>
<p>DoesTree1HasTree2中，如果Tree2为空，则说明第二棵树遍历完了，即匹配成功，</p>
<p>tree1为空有两种情况（1）如果tree1为空&amp;&amp;tree2不为空说明不匹配，</p>
<p>（2）如果tree1为空，tree2为空，说明匹配。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123;</span><br><span class="line">        boolean result = false;</span><br><span class="line">            if(root1 != null &amp;&amp; root2 != null)&#123;</span><br><span class="line">                if(root1.val == root2.val)&#123;</span><br><span class="line">                    result = DoesTree1HaveTree2(root1,root2);</span><br><span class="line">                &#125;</span><br><span class="line">                if(!result)&#123;result = HasSubtree(root1.left, root2);&#125;</span><br><span class="line">                if(!result)&#123;result = HasSubtree(root1.right, root2);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean DoesTree1HaveTree2(TreeNode root1,TreeNode root2)&#123;</span><br><span class="line">            if(root1 == null &amp;&amp; root2 != null) return false;</span><br><span class="line">            if(root2 == null) return true;</span><br><span class="line">            if(root1.val != root2.val) return false;</span><br><span class="line">            return DoesTree1HaveTree2(root1.left, root2.left) &amp;&amp; DoesTree1HaveTree2(root1.right, root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="３．二叉树的镜像"><a href="#３．二叉树的镜像" class="headerlink" title="３．二叉树的镜像"></a>３．二叉树的镜像</h4><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<blockquote>
<p>分析：递归</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public void Mirror(TreeNode root) &#123;</span><br><span class="line">        if(root==null)</span><br><span class="line">        	return;</span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left=root.right;</span><br><span class="line">        root.right=temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-顺时针打印矩阵"><a href="#4-顺时针打印矩阵" class="headerlink" title="4.顺时针打印矩阵"></a>4.顺时针打印矩阵</h4><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<blockquote>
<p>分析：顺时针打印就是按圈数循环打印，一圈包含两行或者两列，在打印的时候会出现某一圈中只包含一行，要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;</span><br><span class="line">         ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();</span><br><span class="line">	       int rows=matrix.length;//行数</span><br><span class="line">	       int color=matrix[0].length;//列数</span><br><span class="line">	       int c=((rows&gt;color?color:rows)-1)/2+1;//圈数</span><br><span class="line">	       for(int i=0;i&lt;c;i++) &#123;</span><br><span class="line">	    	   //从左到右</span><br><span class="line">	    	   for(int j=i;j&lt;color-i;j++) &#123;</span><br><span class="line">	    		   list.add(matrix[i][j]);</span><br><span class="line">	    	   &#125;</span><br><span class="line">	    	   //从上到下</span><br><span class="line">	    	   for(int z=i+1;z&lt;rows-i;z++) &#123;</span><br><span class="line">	    		   list.add(matrix[z][color-1-i]);</span><br><span class="line">	    	   &#125;</span><br><span class="line">	    	   //从右到左</span><br><span class="line">	    	   for(int a=color-2-i;a&gt;=i&amp;&amp;(rows-i-1!=i);a--) &#123;</span><br><span class="line">	    		   list.add(matrix[rows-1-i][a]);</span><br><span class="line">	    	   &#125;</span><br><span class="line">	    	   //从下到上</span><br><span class="line">	    	   for(int b=rows-2-i;b&gt;i&amp;&amp;(color-1-i!=i);b--) &#123;</span><br><span class="line">	    		   list.add(matrix[b][i]);</span><br><span class="line">	    	   &#125;</span><br><span class="line">	       &#125;</span><br><span class="line">	       return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="５．包含min函数的栈"><a href="#５．包含min函数的栈" class="headerlink" title="５．包含min函数的栈"></a>５．包含min函数的栈</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<blockquote>
<p>分析：应用一个辅助栈，压的时候，如果A栈的压入比B栈压入大，B栈不压，小于等于，AB栈同时压入，出栈，如果，AB栈顶元素不等，A出，B不出。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">	Stack&lt;Integer&gt; stack1=new Stack&lt;&gt;();</span><br><span class="line">	Stack&lt;Integer&gt; stack2=new Stack&lt;&gt;();</span><br><span class="line">	 public void push(int node) &#123;</span><br><span class="line">	        stack1.push(node);</span><br><span class="line">	        if(stack2.isEmpty()) &#123;</span><br><span class="line">	        	stack2.push(node);</span><br><span class="line">	        &#125;</span><br><span class="line">	        if(stack2.peek()&gt;node) &#123;</span><br><span class="line">	        	stack2.push(node);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public void pop() &#123;</span><br><span class="line">	        if(stack1.peek()==stack2.peek())</span><br><span class="line">	        	stack2.pop();</span><br><span class="line">	        stack1.pop();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public int top() &#123;</span><br><span class="line">	        return stack1.peek();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    public int min() &#123;</span><br><span class="line">	        return stack2.peek();</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="６．栈的压入、弹出序列"><a href="#６．栈的压入、弹出序列" class="headerlink" title="６．栈的压入、弹出序列"></a>６．栈的压入、弹出序列</h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<blockquote>
<p>分析：借助辅助栈，依次按原先顺序弹入，并同事判断是否等于弹出序列的栈顶元素，若等于则继续弹入，判断结果依照辅助栈是否为空。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public boolean IsPopOrder(int [] pushA,int [] popA) &#123;</span><br><span class="line">      if(pushA.length == 0 || popA.length == 0)</span><br><span class="line">            return false;</span><br><span class="line">        Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();</span><br><span class="line">        //用于标识弹出序列的位置</span><br><span class="line">        int popIndex = 0;</span><br><span class="line">        for(int i = 0; i&lt; pushA.length;i++)&#123;</span><br><span class="line">            s.push(pushA[i]);</span><br><span class="line">            //如果栈不为空，且栈顶元素等于弹出序列</span><br><span class="line">            while(!s.empty() &amp;&amp;s.peek() == popA[popIndex])&#123;</span><br><span class="line">                //出栈</span><br><span class="line">                s.pop();</span><br><span class="line">                //弹出序列向后一位</span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="７．从上往下打印二叉树"><a href="#７．从上往下打印二叉树" class="headerlink" title="７．从上往下打印二叉树"></a>７．从上往下打印二叉树</h4><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<blockquote>
<p>分析：用arraylist来模拟一个队列list1来存储相应的TreeNode,循环(直至移除完)移除一个元素并将其存在的左右子树的值存在list1中，移除的元素存在arraylist　list2中，用来作为答案的返回结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while (queue.size() != 0) &#123;</span><br><span class="line">            TreeNode temp = queue.remove(0);</span><br><span class="line">            if (temp.left != null)&#123;</span><br><span class="line">                queue.add(temp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (temp.right != null) &#123;</span><br><span class="line">                queue.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(temp.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="８．二叉搜索树的后序遍历序列"><a href="#８．二叉搜索树的后序遍历序列" class="headerlink" title="８．二叉搜索树的后序遍历序列"></a>８．二叉搜索树的后序遍历序列</h4><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<blockquote>
<p>分析：二叉搜索树最后一个元素是根（值为x），前一段为左子树（值小于x）,后一段为右子树（值大于x）。通过递归判断并返回结果。将递归方法写成单独的方法，递归终结条件为start&gt;=end</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean VerifySquenceOfBST(int [] sequence) &#123;</span><br><span class="line">        if(sequence==null||sequence.length==0)</span><br><span class="line">        	return false;</span><br><span class="line">        return a(sequence,0,sequence.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">public boolean a(int []sequence,int start,int end) &#123;</span><br><span class="line">	if(start&gt;=end)</span><br><span class="line">		return true;</span><br><span class="line">	int i=start;</span><br><span class="line">	while(sequence[i]&lt;sequence[end]) &#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int j=i;j&lt;end;j++) &#123;</span><br><span class="line">		if(sequence[j]&lt;sequence[end])</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	boolean left=a(sequence,start,i-1);</span><br><span class="line">	boolean right=a(sequence,i,end-1);</span><br><span class="line">	return left&amp;&amp;right;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-复杂链表的复制"><a href="#9-复杂链表的复制" class="headerlink" title="9.复杂链表的复制"></a>9.复杂链表的复制</h4><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） </p>
<blockquote>
<p>分析：1、遍历链表，复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</p>
<p>2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</p>
<p>３、拆分链表，将链表拆分为原链表和复制后的链表．</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">public RandomListNode Clone(RandomListNode pHead) &#123;</span><br><span class="line">        if(pHead == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode currentNode = pHead;</span><br><span class="line">        //1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面；</span><br><span class="line">        while(currentNode != null)&#123;</span><br><span class="line">            RandomListNode cloneNode = new RandomListNode(currentNode.label);</span><br><span class="line">            RandomListNode nextNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode;</span><br><span class="line">            cloneNode.next = nextNode;</span><br><span class="line">            currentNode = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        //2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next;</span><br><span class="line">        while(currentNode != null) &#123;</span><br><span class="line">            currentNode.next.random = currentNode.random==null?null:currentNode.random.next;</span><br><span class="line">            currentNode = currentNode.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        //3、拆分链表，将链表拆分为原链表和复制后的链表</span><br><span class="line">        currentNode = pHead;</span><br><span class="line">        RandomListNode pCloneHead = pHead.next;</span><br><span class="line">        while(currentNode != null) &#123;</span><br><span class="line">            RandomListNode cloneNode = currentNode.next;</span><br><span class="line">            currentNode.next = cloneNode.next;</span><br><span class="line">            cloneNode.next = cloneNode.next==null?null:cloneNode.next.next;</span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        return pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="１０．数组中出现次数超过一半的数字"><a href="#１０．数组中出现次数超过一半的数字" class="headerlink" title="１０．数组中出现次数超过一半的数字"></a>１０．数组中出现次数超过一半的数字</h4><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<blockquote>
<p>分析：思路一：用hashmap的键存数，值存该数的次数。</p>
<p>思路二：排序，若中间的数与第一个数相同则该数过半，即为所求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; public class Solution &#123;</span><br><span class="line">&gt;    public int MoreThanHalfNum_Solution(int [] array) &#123;</span><br><span class="line">&gt;         //用hashmap</span><br><span class="line">&gt; 	HashMap&lt;Integer, Integer&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">&gt; 	for(int i=0;i&lt;array.length;i++) &#123;</span><br><span class="line">&gt; 		if(!hashMap.containsKey(array[i])) &#123;</span><br><span class="line">&gt; 			hashMap.put(array[i], 1);</span><br><span class="line">&gt; 		&#125;else &#123;</span><br><span class="line">&gt; 			int count = hashMap.get(array[i]);</span><br><span class="line">&gt; 			hashMap.put(array[i], ++count);</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; 		Iterator iterator=hashMap.entrySet().iterator();</span><br><span class="line">&gt; 		while(iterator.hasNext()) &#123;</span><br><span class="line">&gt; 			Map.Entry&lt;Integer, Integer&gt; entry = (Entry&lt;Integer, Integer&gt;) iterator.next();</span><br><span class="line">&gt; 			int key=entry.getKey();</span><br><span class="line">&gt; 			int value=entry.getValue();</span><br><span class="line">&gt; 			if(value&gt;array.length/2)</span><br><span class="line">&gt; 				return key;</span><br><span class="line">&gt; 		&#125;</span><br><span class="line">&gt; 		return 0;</span><br><span class="line">&gt; 	&#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/22/算法总结（二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/22/算法总结（二/" itemprop="url">算法总结（二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T09:26:51+08:00">
                2018-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-用两个栈实现队列"><a href="#1-用两个栈实现队列" class="headerlink" title="1.用两个栈实现队列"></a>1.用两个栈实现队列</h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p>分析：入队列：入栈Ａ,入栈顺序与入队列顺序一致。</p>
<p>　　　出队列：若栈Ａ与Ｂ为空则报异常，循环直至Ａ为空，将Ａ全部出栈进入Ｂ.</p>
<p>​             然后Ｂ出栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">　　Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if(stack1.empty()&amp;&amp;stack2.empty())&#123;</span><br><span class="line">            throw new RuntimeException(&quot;Queue is empty!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(stack2.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-旋转数组的最小数字"><a href="#2-旋转数组的最小数字" class="headerlink" title="2.旋转数组的最小数字"></a>2.旋转数组的最小数字</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<blockquote>
<p>分析：采用二分法解答这个问题， </p>
<p>  mid = low + (high - low)/2 </p>
<p>  需要考虑三种情况： </p>
<p>  (1)array[mid] &gt; array[high]: </p>
<p>  出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 </p>
<p>  low = mid + 1 </p>
<p>  (2)array[mid] == array[high]: </p>
<p>  出现这种情况的array类似 [1,0,1,1,1]   或者[1,1,1,0,1]，此时最小数字不好判断在mid左边 </p>
<p>  还是右边,这时只好一个一个试 ， </p>
<p>  high = high - 1 </p>
<p>  (3)array[mid] &lt; array[high]: </p>
<p>  出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左 </p>
<p>  边。因为右边必然都是递增的。 </p>
<p>  high = mid</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line">        int low = 0 ; int high = array.length - 1;   </span><br><span class="line">        while(low &lt; high)&#123;</span><br><span class="line">            int mid = low + (high - low) / 2;        </span><br><span class="line">            if(array[mid] &gt; array[high])&#123;</span><br><span class="line">                low = mid + 1;</span><br><span class="line">            &#125;else if(array[mid] == array[high])&#123;</span><br><span class="line">                high = high - 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        return array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="３．斐波那契数列"><a href="#３．斐波那契数列" class="headerlink" title="３．斐波那契数列"></a>３．斐波那契数列</h4><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p>n&lt;=39</p>
<blockquote>
<p>分析：动态规划</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(n&lt;=1)&#123;</span><br><span class="line">    return n;</span><br><span class="line">&#125;</span><br><span class="line">int[] record = new int[n+1];</span><br><span class="line">record[0] = 0;</span><br><span class="line">record[1] = 1;</span><br><span class="line">for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">    record[i] = record[i-1] + record[i-2];</span><br><span class="line">&#125;</span><br><span class="line">return record[n];</span><br></pre></td></tr></table></figure>
<h4 id="４．跳台阶"><a href="#４．跳台阶" class="headerlink" title="４．跳台阶"></a>４．跳台阶</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<blockquote>
<p>分析： </p>
<p>对于本题,前提只有 一次 1阶或者2阶的跳法。  </p>
<p>   a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);  </p>
<p>   b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)  </p>
<p>   c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)   </p>
<p>   d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int JumpFloor(int target) &#123;</span><br><span class="line">       if (target &lt;= 0) &#123;</span><br><span class="line">           return -1;</span><br><span class="line">       &#125; else if (target == 1) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125; else if (target ==2) &#123;</span><br><span class="line">           return 2;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return  JumpFloor(target-1)+JumpFloor(target-2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="５．变态跳台阶"><a href="#５．变态跳台阶" class="headerlink" title="５．变态跳台阶"></a>５．变态跳台阶</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<blockquote>
<p>分析：</p>
<p>关于本题，前提是n个台阶会有一次n阶的跳法。分析如下: </p>
<p>  f(1) = 1 </p>
<p>  f(2) = f(2-1) + f(2-2)         //f(2-2) 表示2阶一次跳2阶的次数。 </p>
<p>  f(3) = f(3-1) + f(3-2) + f(3-3)  </p>
<p>  … </p>
<p>  f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n)  </p>
<p>  说明：  </p>
<p>  1）这里的f(n) 代表的是n个台阶有一次1,2,…n阶的 跳法数。 </p>
<p>  2）n = 1时，只有1种跳法，f(1) = 1 </p>
<p>  3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2)  </p>
<p>  4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， </p>
<p>​        那么就是第一次跳出1阶后面剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) </p>
<p>​       因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) </p>
<p>  5) n = n时，会有n中跳的方式，1阶、2阶…n阶，得出结论： </p>
<p>​       f(n) = f(n-1)+f(n-2)+…+f(n-(n-1)) + f(n-n) =&gt;   f(0) + f(1) + f(2) + f(3) + … + f(n-1) </p>
<p>  6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： </p>
<p>​       f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) =   f(0) + f(1) + f(2) + f(3) + … + f(n-2) </p>
<p>​       f(n) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) +   f(n-1) = f(n-1) + f(n-1) </p>
<p>​       可以得出： </p>
<p>​       f(n) = 2*f(n-1)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        if (target &lt;= 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125; else if (target == 1) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 2 * JumpFloorII(target - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="６．矩形覆盖"><a href="#６．矩形覆盖" class="headerlink" title="６．矩形覆盖"></a>６．矩形覆盖</h4><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<blockquote>
<p>分析：依旧是斐波那契数列 </p>
<p>  2<em>n的大矩形，和n个2</em>1的小矩形 </p>
<p>  其中target*2为大矩阵的大小 </p>
<p>  有以下几种情形： </p>
<p>  1⃣️target &lt;= 0 大矩形为&lt;= 2*0,直接return 1； </p>
<p>  2⃣️target = 1大矩形为2*1，只有一种摆放方法，return1； </p>
<p>  3⃣️target = 2 大矩形为2*2，有两种摆放方法，return2； </p>
<p>  4⃣️target = n 分为两步考虑： </p>
<table>
<thead>
<tr>
<th>√</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>  因为，摆放了一块1<em>2的小矩阵（用√√表示），对应下方的1</em>2（用××表示）摆放方法就确定了，所以为f(targte-2) </p>
<table>
<thead>
<tr>
<th>√</th>
<th>√</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>×</td>
<td>×</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">      if(target  &lt;= 1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(target*2 == 2)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(target*2 == 4)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return RectCover((target-1))+RectCover(target-2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="７．二进制中1的个数"><a href="#７．二进制中1的个数" class="headerlink" title="７．二进制中1的个数"></a>７．二进制中1的个数</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<blockquote>
<p>分析：思想一：用1（1自身左移运算或本身无符号右运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数</p>
<p>思想二：把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static int NumberOf1_low(int n) &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       int flag = 1;</span><br><span class="line">       while (flag != 0) &#123;</span><br><span class="line">           if ((n &amp; flag) != 0) &#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">           flag = flag &lt;&lt; 1;</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br><span class="line">   //--------------------最优解----------------------------</span><br><span class="line">   public static int NumberOf1(int n) &#123;</span><br><span class="line">       int count = 0;</span><br><span class="line">       while (n != 0) &#123;</span><br><span class="line">           ++count;</span><br><span class="line">           n = (n - 1) &amp; n;</span><br><span class="line">       &#125;</span><br><span class="line">       return count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="８．数值的整数次方"><a href="#８．数值的整数次方" class="headerlink" title="８．数值的整数次方"></a>８．数值的整数次方</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<blockquote>
<p>分析：１．全面考察指数的正负、底数是否为零等情况。</p>
<p> 2.写出指数的二进制表达，例如13表达为二进制1101。</p>
<p>３.举例:10^1101 = 10^0001<em>10^0100</em>10^1000。</p>
<p>４.通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public double Power(double base, int n) &#123;</span><br><span class="line">      double base1=base;</span><br><span class="line"> double res=1;</span><br><span class="line"> int n1;</span><br><span class="line"> if(n&gt;0) &#123;</span><br><span class="line">	 n1=n;</span><br><span class="line"> &#125;else if(n&lt;0) &#123;</span><br><span class="line">	 n1=-n;</span><br><span class="line">	 if(base==0) &#123;</span><br><span class="line">		 throw new RuntimeException(&quot;分母不能为0&quot;);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;else &#123;</span><br><span class="line">	 return 1;</span><br><span class="line"> &#125;</span><br><span class="line"> while(n1!=0) &#123;</span><br><span class="line">	 if((n1&amp;1)==1)</span><br><span class="line">		 res*=base1;</span><br><span class="line">	 base1*=base1;//翻倍</span><br><span class="line">	 n1&gt;&gt;=1;</span><br><span class="line"> &#125;</span><br><span class="line"> return n&gt;0?res:(1/res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="９．调整数组顺序使奇数位于偶数前面"><a href="#９．调整数组顺序使奇数位于偶数前面" class="headerlink" title="９．调整数组顺序使奇数位于偶数前面"></a>９．调整数组顺序使奇数位于偶数前面</h4><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<blockquote>
<p>分析：</p>
<p>第一个思路：类似冒泡算法，前偶后奇数就交换；</p>
<p>第二个思路：再创建一个数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public void reOrderArray(int [] array) &#123;</span><br><span class="line">        if(array.length==0||array.length==1) return;</span><br><span class="line">        int oddCount=0,oddBegin=0;</span><br><span class="line">        int[] newArray=new int[array.length];</span><br><span class="line">        for(int i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">            if((array[i]&amp;1)==1) oddCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">            if((array[i]&amp;1)==1) newArray[oddBegin++]=array[i];</span><br><span class="line">            else newArray[oddCount++]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;array.length;i++)&#123;</span><br><span class="line">            array[i]=newArray[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-链表中倒数第k个结点"><a href="#10-链表中倒数第k个结点" class="headerlink" title="10.链表中倒数第k个结点"></a>10.链表中倒数第k个结点</h4><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<blockquote>
<p>分析：两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指正走(k-1)步，到达第k个节点。然后两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) &#123;</span><br><span class="line">        if(head==null||k&lt;=0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode last=head;       </span><br><span class="line">        for(int i=1;i&lt;k;i++)&#123;</span><br><span class="line">            if(pre.next!=null)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(pre.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            last=last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-反转链表"><a href="#11-反转链表" class="headerlink" title="11.反转链表"></a>11.反转链表</h4><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<blockquote>
<p>分析：入栈出栈</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/21/算法总结（一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/算法总结（一/" itemprop="url">算法总结（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-21T20:38:51+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="１．二维数组中的查找"><a href="#１．二维数组中的查找" class="headerlink" title="１．二维数组中的查找"></a>１．二维数组中的查找</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<blockquote>
<p>分析：利用左下角向上递减，向右递增的性质。</p>
<p>１．先定位左下角坐标[rows-1,0]。</p>
<p>２．通过while循环查找。若该数比左下角大，则向右移，即列增。小则左移，即行增。相等则返回true。超出while条件范围且没找到该数，则返回false;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">       int rows = array.length;</span><br><span class="line">       int cols = array[0].length;</span><br><span class="line">       int i=rows-1,j=0;</span><br><span class="line">       while(i&gt;=0 &amp;&amp; j&lt;cols)&#123;</span><br><span class="line">           if(target&lt;array[i][j])</span><br><span class="line">               i--;</span><br><span class="line">           else if(target&gt;array[i][j])</span><br><span class="line">               j++;</span><br><span class="line">           else</span><br><span class="line">               return true;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<blockquote>
<p>分析：替换字符串的问题：</p>
<p>从后往前移位，对每个需要移位的位，计算出需要移位的数量（空格数×与之前字符串长度之差）。</p>
</blockquote>
<h4 id="３．从尾到头打印链表"><a href="#３．从尾到头打印链表" class="headerlink" title="３．从尾到头打印链表"></a>３．从尾到头打印链表</h4><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<blockquote>
<p>分析：递归法：</p>
<p>看似是从前往后，实则从后往前</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList=new ArrayList&lt;Integer&gt;();</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        if(listNode!=null)&#123;</span><br><span class="line">            this.printListFromTailToHead(listNode.next);</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="４．重建二叉树"><a href="#４．重建二叉树" class="headerlink" title="４．重建二叉树"></a>４．重建二叉树</h4><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p>分析：递归法（重点是建立node.left和node.right分别与node的关系）</p>
<p>前序：一个整体中，第一个为根节点。</p>
<p>中序：根节点的左侧为左子树，右侧为右子树。</p>
<p>然后分别将左右子树作为整体递归，每层返回的值作为左右子树的根节点，即可建立node.left和node.right分别与node的关系。最终返回二叉树的根节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span><br><span class="line">    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) &#123;</span><br><span class="line">         </span><br><span class="line">        if(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root=new TreeNode(pre[startPre]);</span><br><span class="line">         </span><br><span class="line">        for(int i=startIn;i&lt;=endIn;i++)</span><br><span class="line">            if(in[i]==pre[startPre])&#123;</span><br><span class="line">                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);</span><br><span class="line">                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);</span><br><span class="line">                      break;</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/20/删除链表中重复的结点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/20/删除链表中重复的结点/" itemprop="url">删除链表中重复的结点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-20T11:55:25+08:00">
                2018-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。-例如，链表1-gt-2-gt-3-gt-3-gt-4-gt-4-gt-5-处理后为-1-gt-2-gt-5"><a href="#在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。-例如，链表1-gt-2-gt-3-gt-3-gt-4-gt-4-gt-5-处理后为-1-gt-2-gt-5" class="headerlink" title="在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5"></a>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ListNode deleteDuplication(ListNode pHead)</span><br><span class="line">    &#123;</span><br><span class="line">         if(pHead==null||pHead.next==null)</span><br><span class="line">        	 return pHead;</span><br><span class="line">         if(pHead.val==pHead.next.val) &#123;</span><br><span class="line">        	ListNode node=pHead.next;</span><br><span class="line">        	while(node!=null&amp;&amp;node.val==pHead.val) &#123;</span><br><span class="line">        		node=node.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        	return deleteDuplication(node);</span><br><span class="line">         &#125;else &#123;</span><br><span class="line">        	 pHead.next=deleteDuplication(pHead.next);</span><br><span class="line">        	 return pHead;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/20/字符流中第一个不重复的字符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/20/字符流中第一个不重复的字符/" itemprop="url">字符流中第一个不重复的字符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-20T10:37:01+08:00">
                2018-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。"><a href="#请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。" class="headerlink" title="请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。"></a>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">	 * HashMap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</span><br><span class="line">	 * HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;</span><br><span class="line">	 * HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap; 可能会导致数据的不一致。如果需要同步，可以用</span><br><span class="line">	 * Collections的synchronizedMap方法使HashMap具有同步的能力。</span><br><span class="line">	 *  LinkedHashMap</span><br><span class="line">	 * LinkedHashMap也是一个HashMap,但是内部维持了一个双向链表,可以保持顺序</span><br><span class="line">	 * </span><br><span class="line">	 * @param ch</span><br><span class="line">	 */</span><br><span class="line">	Map&lt;Character, Integer&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	public void Insert(char ch) &#123;</span><br><span class="line">		int c = map.getOrDefault(ch, 0);</span><br><span class="line">		map.put(ch, ++c);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// return the first appearence once char in current stringstream</span><br><span class="line">	public char FirstAppearingOnce() &#123;</span><br><span class="line">		for (Character c : map.keySet()) &#123;</span><br><span class="line">			if (map.get(c) == 1)</span><br><span class="line">				return c;</span><br><span class="line">		&#125;</span><br><span class="line">		return &apos;#&apos;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">佩琪</p>
              <p class="site-description motion-element" itemprop="description">JAVA</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">佩琪</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
