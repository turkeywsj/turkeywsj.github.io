<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="JAVA">
<meta property="og:type" content="website">
<meta property="og:title" content="小猪佩琪">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小猪佩琪">
<meta property="og:description" content="JAVA">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小猪佩琪">
<meta name="twitter:description" content="JAVA">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>小猪佩琪</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小猪佩琪</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小猪佩琪的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/08/Ajax技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/08/Ajax技术/" itemprop="url">Ajax技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-08T20:52:47+08:00">
                2018-11-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-当下谁在用Ajax"><a href="#1-当下谁在用Ajax" class="headerlink" title="1.当下谁在用Ajax"></a><em>1.当下谁在用Ajax</em></h3><h3 id="2-ajax开发模式与传统开发模式的比较"><a href="#2-ajax开发模式与传统开发模式的比较" class="headerlink" title="2.ajax开发模式与传统开发模式的比较"></a><em>2.ajax开发模式与传统开发模式的比较</em></h3><p>由于ajax是一个客户端技术，所以无论使用那种服务端技术都可以使用ajax。</p>
<p>传统：在传统的web应用模式中，页面每一次操作都将会触发一次返回web服务器的HTTP请求，服务器进行相应的处理后，返回一个HTML页面给客户端。</p>
<p>ajax：而在ajax应用中，页面中用户的操作将通过ajax引擎与服务器进行通信，然后将返回结果提交给客户端页面的ajax引擎，再由ajax引擎来决定将这些数据插入到页面的指定位置。</p>
<p>优点：在ajax应用开发模式中通过JavaScript实现在不刷新整个页面的情况下，对部分数据进行更新，从而降低了网络流量，给用户带来更好的体验。</p>
<h3 id="3-ajax使用的技术"><a href="#3-ajax使用的技术" class="headerlink" title="3.ajax使用的技术"></a><em>3.ajax使用的技术</em></h3><p>Ajax是XMLHttpRequest对象和JavaScript,XML,CSS,DOM（文档对象模型）等技术的组合。</p>
<h3 id="4-使用XMLHttpRequest对象"><a href="#4-使用XMLHttpRequest对象" class="headerlink" title="4.使用XMLHttpRequest对象"></a><em>4.使用XMLHttpRequest对象</em></h3><h5 id="1-初始化XMLHttpRequst对象"><a href="#1-初始化XMLHttpRequst对象" class="headerlink" title="1.初始化XMLHttpRequst对象"></a>1.初始化XMLHttpRequst对象</h5><p>if(windom.XMLHttpRequest){ //非IE浏览器</p>
<p>http_request=new XMLHttpRequest();</p>
<p>}else if(window.ActiveXObject){//IE浏览器</p>
<p>try{</p>
<p>http_request=new ActiveXObject(“Msxml2.XMLHTTP”);</p>
<p>}catch(e){</p>
<p>try{</p>
<p>http_request=new ActiveXObject(“Microsoft.XMLHTTP”);</p>
<p>}catch(e){}</p>
<p>}</p>
<p>}</p>
<h5 id="2-XMLHttpRequest对象的常用方法"><a href="#2-XMLHttpRequest对象的常用方法" class="headerlink" title="2.XMLHttpRequest对象的常用方法"></a>2.XMLHttpRequest对象的常用方法</h5><ul>
<li><p>open()方法</p>
<p>用于设置进行异步请求目标的URL，请求方法以及其他参数信息</p>
<p>语法:</p>
<p>open(“method”,”url”[,asyncFlag[,”userName”,[“password”]]])</p>
<p>method：用于指定请求的类型，一般为get或post</p>
<p>url:用于指定请求的地址，可以使用绝对地址或相对地址。</p>
<p>asyncFlag:为可选参数，用于指定请求方式，异步请求为true,同步请求为false,默认为true。</p>
<p>userName：为可选参数，用于指定请求用户名，没有时可以省略。</p>
<p>password：为可选参数，用于指定请求密码，没有时可以省略。</p>
</li>
<li><p>send()方法</p>
<p>send()方法用于向服务器发送请求，如果请求声明为异步，该方法将立即返回，否则将等到接收到响应为止。</p>
<p>语法：</p>
<p>send(content)</p>
<p>content:用于指定发送的数据</p>
</li>
<li><p>setRequestHeader()方法</p>
<p>setRequestHeader()方法用于为请求的HTTP头设置值。</p>
<p>语法：</p>
<p>setRequestHeader(“header”,”value”)</p>
<p>header：用于设置HTTP头</p>
<p>value：用于为指定的HTTP头设置值</p>
</li>
<li><p>getAllResponseHeaders()方法</p>
<p>用于以字符串形式返回完整的HTTP头信息</p>
</li>
</ul>
<h5 id="3-XMLHttpRequest的常用属性"><a href="#3-XMLHttpRequest的常用属性" class="headerlink" title="3.XMLHttpRequest的常用属性"></a>3.XMLHttpRequest的常用属性</h5><ul>
<li><p>onreadystatechange属性</p>
<p>用于指定状态改变时所触发的事件处理器。</p>
<p>eg:指定状态改变时所触发javaScript函数getResult的代码：</p>
<p>http_request.onreadystatechange=getResult;</p>
</li>
<li><p>readyState属性</p>
<p>用于获取请求的状态。</p>
<p>0：为初始化</p>
<p>1：正在加载</p>
<p>2：已加载</p>
<p>3：交互中</p>
<p>4：完成</p>
</li>
<li><p>responseText属性</p>
<p>用于获取服务器的响应，表示为字符串</p>
</li>
<li><p>responseXML属性</p>
<p>用于获取服务器的响应，表示为XML</p>
</li>
<li><p>status属性</p>
<p>用于返回服务器的HTTP状态码</p>
<p>200：表示成功</p>
<p>202：表示请求被接受，但尚未成功</p>
<p>400：错取的请求</p>
<p>404：文件未找到</p>
<p>500：内部服务器错误</p>
</li>
<li><p>statusText属性</p>
<p>用于返回HTTP状态码对应的文本</p>
</li>
</ul>
<h3 id="5-：服务器通信——发送请求与处理响应"><a href="#5-：服务器通信——发送请求与处理响应" class="headerlink" title="5.：服务器通信——发送请求与处理响应"></a><em>5.：服务器通信——发送请求与处理响应</em></h3><h5 id="1-发送请求"><a href="#1-发送请求" class="headerlink" title="1.发送请求"></a>1.发送请求</h5><ul>
<li>初始化XMLHttpRequest对象</li>
<li>为XMLHttpRequest对象指定一个返回结果处理函数（回调函数）</li>
<li>创建一个与服务器的连接</li>
<li>向服务器发送请求</li>
</ul>
<h5 id="2-处理服务器响应"><a href="#2-处理服务器响应" class="headerlink" title="2.处理服务器响应"></a>2.处理服务器响应</h5><p>XMLHttpRequest对象提供了两个用来访问服务器响应的属性一个是requestText属性，返回的是字符串响应，另一个是responseXML属性，返回XML响应。</p>
<h3 id="6-解决中文乱码问题"><a href="#6-解决中文乱码问题" class="headerlink" title="6.解决中文乱码问题"></a><em>6.解决中文乱码问题</em></h3><p>Ajax不支持多种字符集，它默认的字符集是utf-8，所以默认在应用ajax技术的程序中应及时进行编码转换，否则中文乱码。</p>
<p>一般情况下，有以下两种情况可以出现中文乱码：</p>
<p>发送请求时出现中文乱码</p>
<p>获取服务器的响应结果时出现中文乱码</p>
<h3 id="7-ajax重构"><a href="#7-ajax重构" class="headerlink" title="7.ajax重构"></a><em>7.ajax重构</em></h3><p>ajax重构大致可以分成以下三个步骤：</p>
<p>1.创建一个单独的js文件</p>
<p>2.在需要应用ajax的页面中应用以下渔具包括步骤一中创建的js文件</p>
<p>3.在需要应用ajax的页面中编写错误处理方法</p>
<p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/JSTL标签库简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/JSTL标签库简介/" itemprop="url">JSTL标签库简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-06T22:03:56+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-标签库简介"><a href="#1-标签库简介" class="headerlink" title="1.标签库简介"></a><em>1.标签库简介</em></h3><p>标准标签库实际上是由五个功能不同的标签库组成。分别是：核心标签库，格式标签库，SQL标签库，XML标签库和函数标签库。</p>
<p>核心标签库主要用于完成JSP页面的常用功能，包括jstl的表达式标签，url标签，流程控制标签，循环标签。</p>
<h3 id="2-JSTL的配置"><a href="#2-JSTL的配置" class="headerlink" title="2.JSTL的配置"></a><em>2.JSTL的配置</em></h3><p>由于jstl还不是JSP2.0中的一部分，所以使用之前需要安装并配置jstl。</p>
<p>现在oracle公司官网上下载，然后就可以在web应用中进行配置。配置一共有两种方法：一种是直接将jstl-api-1.2.jar和jstl.impl-1.2.jar复制到web-inf\lib目录，另一种是在eclipse中通过配置构建路径的方法进行添加。</p>
<h3 id="3-表达式标签"><a href="#3-表达式标签" class="headerlink" title="3.表达式标签"></a><em>3.表达式标签</em></h3><h5 id="1-《c-out》输出标签"><a href="#1-《c-out》输出标签" class="headerlink" title="1.《c:out》输出标签"></a>1.《c:out》输出标签</h5><p>语法一——没有标签体</p>
<p>《c:out value=”expression” [escapeXml=”true|false” [default=”true|false”]》</p>
<p>语法二——有标签体</p>
<p>《c:out value=”expression” [escapeXml=”true|false”] /》</p>
<p>   defalutValue</p>
<p>《/c:out》</p>
<p>value:用于指定将要输出的变量或表达式</p>
<p>escapeXml:可选属性，用于指定是否转换为特殊字符。</p>
<p>default:可选属性，用于指定value属性值等于nul时，将要显示的默认值。</p>
<h5 id="2-《c-set》变量设置标签"><a href="#2-《c-set》变量设置标签" class="headerlink" title="2.《c:set》变量设置标签"></a>2.《c:set》变量设置标签</h5><p>语法一——在scope指定的范围内将变量值存储到变量中</p>
<p>《c:set var=”name” value=”value” [scope=”范围”]/》</p>
<p>语法二——在scope指定的范围内将标签体存储到变量中</p>
<p>《c:set var=”name” [scope=”page|request|session|application”]》</p>
<p>标签体</p>
<p>《/c:set》</p>
<p>语法三——将变量值存储在target属性指定的目标对象的propName属性中。</p>
<p>《c:set value=”value” target=”object” property=”proName”/》</p>
<p>语法四——将标签体存储到target属性指定的目标对象的propName属性中。</p>
<p>《c:set target=”object” property=”proName”》</p>
<p>标签体</p>
<p>《/c:set》</p>
<p>var:用于指定变量名</p>
<p>value：用于指定变量值</p>
<p>scope：用于指定变量的作用域</p>
<p>target:用于指定存储变量值或者标签体的目标对象</p>
<p>property:用于指定目标对象存储数据的属性名</p>
<h5 id="3-《c-remove》变量移除标签"><a href="#3-《c-remove》变量移除标签" class="headerlink" title="3.《c:remove》变量移除标签"></a>3.《c:remove》变量移除标签</h5><p>《c:remove var=”name” [scope=”范围”]》</p>
<p>var:用于指定要移除的变量名</p>
<p>scope:用于指定变量的有效范围</p>
<h5 id="4-《c-catch》捕获异常标签"><a href="#4-《c-catch》捕获异常标签" class="headerlink" title="4.《c:catch》捕获异常标签"></a>4.《c:catch》捕获异常标签</h5><p>该标签用于捕获程序中出现的异常，该标签与Java中的try…catch语句类似。</p>
<p>《c:catch [var=”exception”]》</p>
<p>…//可能存在异常的代码</p>
<p>《/c:catch》</p>
<p>var:可选属性，用于指定存储异常信息的变量，如果不需要保存异常信息，可以忽略该属性。</p>
<h3 id="4-URL相关标签"><a href="#4-URL相关标签" class="headerlink" title="4.URL相关标签"></a><em>4.URL相关标签</em></h3><h5 id="1-《c-import》导入标签"><a href="#1-《c-import》导入标签" class="headerlink" title="1.《c:import》导入标签"></a>1.《c:import》导入标签</h5><p>语法一：</p>
<p>《c:import url=”url” [context=”context” [var=”name” [scope=”范围” [charEncoding=”encoding”]》</p>
<p>[标签体]</p>
<p>《/c:import》</p>
<p>语法二：</p>
<p>《c:import url=”url” varReader=”name” [context=”context” [charEncoding=”encoding”]》</p>
<p>[标签体]</p>
<p>《/c:import》</p>
<p>url:用于指定被导入文件资源的url地址</p>
<p>context：上下文路径，用于访问同一服务器的其他web应用，其值必须以“/”开头，如果指定了该属性，那么url属性值也必须以“/“开头。</p>
<p>var:用于指定变量名称</p>
<p>scope；用于指定变量的存在范围，默认值是page。可选值为page,session,request,application.</p>
<p>varReader:定义一个变量名，该变量用于以reader类型存储被包含文件内容。</p>
<p>charEncoding:用于指定被导入文件的编码格式。</p>
<p>标签体：可选，如果需要为导入的文件传递参数，则可以在标签提的位置通过《c:param》标签设置参数。</p>
<h5 id="2-《c-url》动态生成URL标签"><a href="#2-《c-url》动态生成URL标签" class="headerlink" title="2.《c:url》动态生成URL标签"></a>2.《c:url》动态生成URL标签</h5><p>语法一：</p>
<p>《c:url value=”url” [var=”name” [scope=”范围” [context=”context”]/》</p>
<p>语法二：</p>
<p>《c:url value=”url” [var=”name” [scope=”范围” [context=”context”]》</p>
<p>《c:param/》</p>
<p>…</p>
<p>《/c:url》</p>
<p>value:用于指定将要处理的url地址</p>
<p>context：上下文路径，用于访问同一服务器的其他web应用，其值必须以“/”开头，如果指定了该属性，那么url属性值也必须以“/“开头。</p>
<p>var:用于指定变量名称</p>
<p>scope；用于指定变量的存在范围，默认值是page。可选值为page,session,request,application.</p>
<h5 id="3-《c-redirect》重定向标签"><a href="#3-《c-redirect》重定向标签" class="headerlink" title="3.《c:redirect》重定向标签"></a>3.《c:redirect》重定向标签</h5><p>语法一：</p>
<p>《c:redirect url=”url” [context=”context”]/》</p>
<p>语法二：</p>
<p>《c:redirect url=”url” [context=”context”]》</p>
<p>《c:param/》</p>
<p>《/c:redirect》</p>
<p>url:必选属性，用于指定待定向资源的URL，可以使用EL.</p>
<p>context:用于在使用相对路径访问外部context资源时，指定资源的名字。</p>
<h5 id="4-《c-param》传递参数标签"><a href="#4-《c-param》传递参数标签" class="headerlink" title="4.《c:param》传递参数标签"></a>4.《c:param》传递参数标签</h5><p>《c:param name=”paramName” value=”paramValue”/》</p>
<p>name:用于指定参数名</p>
<p>value:用于指定参数值</p>
<h3 id="5-流程控制标签"><a href="#5-流程控制标签" class="headerlink" title="5.流程控制标签"></a><em>5.流程控制标签</em></h3><h5 id="1-《c-if》条件判断标签"><a href="#1-《c-if》条件判断标签" class="headerlink" title="1.《c:if》条件判断标签"></a>1.《c:if》条件判断标签</h5><p>语法一：</p>
<p>《c:if test=”condition” var=”name” [scope=page|session|request|session|application]/》</p>
<p>语法二：</p>
<p>《c:if test=”condition” var=”name” [scope=page|session|request|session|application]》</p>
<p>标签体</p>
<p>《/c:if》</p>
<h5 id="2-《c-choose》条件选择标签"><a href="#2-《c-choose》条件选择标签" class="headerlink" title="2.《c:choose》条件选择标签"></a>2.《c:choose》条件选择标签</h5><p>《c:choose》</p>
<p>标签体 ——由《c:when》和《c:otherwise》标签组成</p>
<p>《/c:choose》</p>
<h5 id="3-《c-when》条件测试标签"><a href="#3-《c-when》条件测试标签" class="headerlink" title="3.《c:when》条件测试标签"></a>3.《c:when》条件测试标签</h5><p>《c:when test=”condition”》</p>
<p>标签体</p>
<p>《/c:when》</p>
<h5 id="4-《c-otherwise》其他条件标签"><a href="#4-《c-otherwise》其他条件标签" class="headerlink" title="4.《c:otherwise》其他条件标签"></a>4.《c:otherwise》其他条件标签</h5><p>《c:otherwise》</p>
<p>标签体</p>
<p>《/c:otherwise》</p>
<h3 id="6-循环标签"><a href="#6-循环标签" class="headerlink" title="6.循环标签"></a><em>6.循环标签</em></h3><h5 id="1-《c-forEach》循环标签"><a href="#1-《c-forEach》循环标签" class="headerlink" title="1.《c:forEach》循环标签"></a>1.《c:forEach》循环标签</h5><p>语法一：集合成员迭代</p>
<p>《c:forEach items=”data” [var=”name” [begin=”start” [end=”finish” [step=”step” [varStatus=”statusName”》</p>
<p>标签体</p>
<p>《/c:foEach》</p>
<p>语法二：数字索引迭代</p>
<p>《c:forEach begin=”start” end=”finish” [var=”name” [varStatus=”statusName” [step=”step”]》</p>
<p>标签体</p>
<p>《/c:forEach》</p>
<p>items；用于指定被循环遍历对象</p>
<p>var:用于指定循环体的变量名</p>
<p>begin:用于指定循环的起始位置</p>
<p>end:用于指定循环的终止位置</p>
<p>step:用于指定循环的步长</p>
<p>varStatus:用于指定循环的状态变量，有四个状态属性</p>
<p>如下：</p>
<p>index——当前循环的索引值(Int)</p>
<p>count——当前循环的循环计数(Int)</p>
<p>first——是否为第一次循环(boolean)</p>
<p>last——是否为最后一次循环(boolean)</p>
<h5 id="2-《c-forTokens》迭代标签"><a href="#2-《c-forTokens》迭代标签" class="headerlink" title="2.《c:forTokens》迭代标签"></a>2.《c:forTokens》迭代标签</h5><p>该标签可以用指定的分隔符将一个字符串分隔开，根据分割的数量确定循环的次数。</p>
<p>《c:forTokens items=”String” delim=”char” [var=”name” [begin=”start” [end=”end” [step=”len” [varStatus=”statusName”]》</p>
<p>标签体</p>
<p>《/c:forTokens》</p>
<p>items:用于指定要迭代的String对象</p>
<p>delims:用于指定分割字符串的分隔符,可以同时有多个分隔符</p>
<p>var:用于指定变量名，该变量中保存了分割后的字符串</p>
<p>begin:用于指定迭代开始的位置，索引值从开始</p>
<p>end:用于指定迭代结束的位置</p>
<p>step:用于指定迭代的步长，默认为1</p>
<p>varStatus：用于指定循环的状态变量，同《c:forEach》一样,该属性也有四个状态变量。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/EL表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/EL表达式/" itemprop="url">EL表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-05T20:51:21+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-EL表达式概述"><a href="#1-EL表达式概述" class="headerlink" title="1.EL表达式概述"></a><em>1.EL表达式概述</em></h3><p>EL是表达式语言，它是JSP2.0中引入的一个新内容。通过EL表达式可以简化在JSP开发中对对象的引用，从而规范页面代码，增加程序的可读性及可维护性。</p>
<h4 id="1-EL表达式的语法"><a href="#1-EL表达式的语法" class="headerlink" title="1.EL表达式的语法"></a>1.EL表达式的语法</h4><p>${expression}</p>
<h4 id="2-EL的特点"><a href="#2-EL的特点" class="headerlink" title="2.EL的特点"></a>2.EL的特点</h4><h3 id="2-与低版本的环境兼容——禁用EL"><a href="#2-与低版本的环境兼容——禁用EL" class="headerlink" title="2.与低版本的环境兼容——禁用EL"></a><em>2.与低版本的环境兼容——禁用EL</em></h3><h6 id="1-使用斜杠“-”符号"><a href="#1-使用斜杠“-”符号" class="headerlink" title="1.使用斜杠“\”符号"></a>1.使用斜杠“\”符号</h6><p>\ ${expression}</p>
<h6 id="2-使用page指令"><a href="#2-使用page指令" class="headerlink" title="2.使用page指令"></a>2.使用page指令</h6><p>《%@ page isELIgnored=”布尔值”》</p>
<p>若属性为true，则表明忽略页面中的EL。</p>
<h6 id="3-在web-xml文件中配置《el-ignored》元素"><a href="#3-在web-xml文件中配置《el-ignored》元素" class="headerlink" title="3.在web.xml文件中配置《el-ignored》元素"></a>3.在web.xml文件中配置《el-ignored》元素</h6><p>该方法适用于禁用web应用中所有JSP页面中的EL。</p>
<p>《jsp-config》</p>
<p>《jsp-property-group》</p>
<p>《url-pattern》*.jsp《/url-pattern》</p>
<p>《el-ignored》true《/el-ignored》</p>
<p>《/jsp-property-group》</p>
<p>《/jsp-config》</p>
<h3 id="3-保留的关键字"><a href="#3-保留的关键字" class="headerlink" title="3.保留的关键字"></a><em>3.保留的关键字</em></h3><p>同Java一样，EL也有自己的保留关键字，再为变量命名时，应该避免使用这些关键字。</p>
<h3 id="4-EL的运算符及优先级"><a href="#4-EL的运算符及优先级" class="headerlink" title="4.EL的运算符及优先级"></a><em>4.EL的运算符及优先级</em></h3><p>[]</p>
<p>()</p>
<p>-(负号) not ! empty</p>
<p>*/ div % mod</p>
<p>+(加号)  -(减号)</p>
<p>&lt; &gt; &lt;= &gt;= lt gt le ge</p>
<p>== != eq ne</p>
<p>&amp;&amp; and</p>
<p>|| or</p>
<p>?:</p>
<p>优先级由高到低</p>
<h4 id="1-通过EL访问数据"><a href="#1-通过EL访问数据" class="headerlink" title="1.通过EL访问数据"></a>1.通过EL访问数据</h4><p>通常情况下，”[]”和“.”是等价的。</p>
<p>${userInfo.id}</p>
<p>${userInfo[id]}</p>
<p>但当属性名中包含一些特殊符号(-或.)时，就只能用“[]”运算符来访问对象的属性。另外。数组元素或list集合中数据的获取，也应该用“.”运算符。</p>
<h4 id="2-在EL中进行算术运算"><a href="#2-在EL中进行算术运算" class="headerlink" title="2.在EL中进行算术运算"></a>2.在EL中进行算术运算</h4><p>EL提供了加减乘除和求余五种算术运算。但“+”与Java中的不同，他不能实现两个字符串之间的连接，只能将数值型字符串转换为数值型，在进行加法运算，否则将抛异常。</p>
<h4 id="3-在EL表达式中判断对象是否为空"><a href="#3-在EL表达式中判断对象是否为空" class="headerlink" title="3.在EL表达式中判断对象是否为空"></a>3.在EL表达式中判断对象是否为空</h4><p>${empty expression}</p>
<p>判断非空</p>
<p>${not empty expression}</p>
<h4 id="4-在EL中进行逻辑关系运算"><a href="#4-在EL中进行逻辑关系运算" class="headerlink" title="4.在EL中进行逻辑关系运算"></a>4.在EL中进行逻辑关系运算</h4><ul>
<li><p>关系运算符</p>
<p>== eq</p>
<p>!= ne</p>
<p>&lt; lt</p>
<p>大于 gt</p>
<p>&lt;= le</p>
<p>大于等于 ge</p>
</li>
<li><p>逻辑运算符</p>
<p>&amp;&amp; and</p>
<p>|| or</p>
<p>! not</p>
</li>
</ul>
<h4 id="5-在EL中进行条件运算"><a href="#5-在EL中进行条件运算" class="headerlink" title="5.在EL中进行条件运算"></a>5.在EL中进行条件运算</h4><p>${条件表达式？表达式一：表达式二}</p>
<h3 id="5-EL的隐含对象"><a href="#5-EL的隐含对象" class="headerlink" title="5.EL的隐含对象"></a><em>5.EL的隐含对象</em></h3><h4 id="1-页面上下文对象"><a href="#1-页面上下文对象" class="headerlink" title="1.页面上下文对象"></a>1.页面上下文对象</h4><p>页面上下文对象为pageContext，用于访问JSP内置对象(如request,response,session,out,page,exception,但不能用于pageContext,config,application)和servletContext。在获取这些内置对象之后，就可以获得其属性值，这些属性值与对象的getXXX()方法相对应，在使用时，去掉方法名中的get,并将首字母改为小写即可。</p>
<p>eg:访问request对象</p>
<p>${pageContext.request}</p>
<p>访问其中的getServerPort()方法</p>
<p>${pageContext.request.serverPort}</p>
<p><strong>注：不可以通过pageContext对象获取保存到request范围中的变量。</strong></p>
<h4 id="2-访问作用域范围的隐含对象"><a href="#2-访问作用域范围的隐含对象" class="headerlink" title="2.访问作用域范围的隐含对象"></a>2.访问作用域范围的隐含对象</h4><p>在EL中提供了四个用于访问作用域范围的隐含对象，即pageScope,requestScope,sessionScope,applicationScope。这四个隐含对象只能取得指定范围内的属性值，而不能取得其他相关信息。</p>
<p>eg:《%request.setAttribute(“userName”,”mr”)%》</p>
<p>$(requestScope.userName)</p>
<h4 id="3-访问环境信息的隐含对象"><a href="#3-访问环境信息的隐含对象" class="headerlink" title="3.访问环境信息的隐含对象"></a>3.访问环境信息的隐含对象</h4><p>在EL中提供了留个访问环境的隐含对象。</p>
<ul>
<li><p>param对象</p>
<p>用于获取请求参数的值，应用在参数值只有一个的情况。</p>
<p>eg:</p>
<p>《input name=”name” value=”text”》</p>
<p>${param.name}</p>
</li>
<li><p>paramValues对象</p>
<p>应用与请求参数名对应多个值时，返回结果为数组。</p>
<p>eg:</p>
<p>《input name=”name” value=”text”》</p>
<p>《input name=”name” value=”text”》</p>
<p>${paramValues.name[0]}</p>
<p><strong>注：在应用param和paramValues对象时，若果指定参数不存在，则返回空的字符串。而不是null。</strong></p>
</li>
<li><p>header和headerValues对象</p>
<p>header对象用于获取HTTP请求的一个具体的header的值。若可能存在同一个header拥有多个不同的情况，这就必须用headerValues对象。</p>
<p>eg:要获取HTTP请求的header的connection(是否持久连接)属性</p>
<p>${header.connection}</p>
</li>
<li><p>initParam对象</p>
<p>该对象用于获取web应用初始化参数。</p>
<p>eg:获取web应用的web.xml文件中设置一个初始化参数author，用于指定作者。</p>
<p>《context-param》</p>
<p>《param-name》author《/param-name》</p>
<p>《param-value》mr《/param-value》</p>
<p>《/context-param》</p>
<p>${initParam.author}</p>
</li>
<li><p>cookie对象</p>
<p>虽然EL中，并没有提供向cookie中保存值的方法，但是它提供了访问由请求设置的cookie的方法，这可以通过cookie的隐含对象实现。</p>
<p>eg:使用response对象设置一个请求有效的cookie对象，然后在使用EL获取该cookie的值。</p>
<p>《%Cookie cookie=new Cookie(“user”,”mr”)</p>
<p>response.addCookie(cookie);</p>
<p>%》</p>
<p>${cookie.user.value}</p>
</li>
</ul>
<h3 id="6-定义和使用EL函数"><a href="#6-定义和使用EL函数" class="headerlink" title="6.定义和使用EL函数"></a><em>6.定义和使用EL函数</em></h3><p>(1)编写一个Java类，并在该类中编写公用静态方法，用于实现自定义EL函数的具体功能。</p>
<p>(2)编写标签库描述文件，对函数进行声明。该文件的拓展名为.tld，被保存到web应用的web-inf文件夹下。</p>
<p>(3)在JSP页面中引用标签库，并调用定义的EL函数，实现相应的功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/04/java-web的数据库操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/04/java-web的数据库操作/" itemprop="url">java web的数据库操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-04T16:46:32+08:00">
                2018-11-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-JDBC技术"><a href="#1-JDBC技术" class="headerlink" title="1.JDBC技术"></a><em>1.JDBC技术</em></h3><h4 id="1-jdbc简介"><a href="#1-jdbc简介" class="headerlink" title="1.jdbc简介"></a>1.jdbc简介</h4><p>jdbc是Java程序操作数据库的API。</p>
<h4 id="2-jdbc连接数据库的过程"><a href="#2-jdbc连接数据库的过程" class="headerlink" title="2.jdbc连接数据库的过程"></a>2.jdbc连接数据库的过程</h4><ul>
<li><p>注册数据库驱动</p>
<p>Class.forName(“com.mysql.jdbc.Driver”)</p>
</li>
<li><p>构造数据库连接url</p>
<p>DriverManager.getConnection(url,username,password)</p>
</li>
</ul>
<h3 id="2-JDBC-API"><a href="#2-JDBC-API" class="headerlink" title="2.JDBC API"></a><em>2.JDBC API</em></h3><p>1.connection接口</p>
<p>connection接口位于java.sql包中，是与特定数据库的连接对话。</p>
<p>2.DriverManager类</p>
<p>它是jdbc中的管理层，通过DriverManager类可以管理数据库厂商提供的驱动程序，并建立应用程序与数据库之间的连接。</p>
<p>3.Statement接口</p>
<p>它封装了jdbc执行sql语句的方法。</p>
<p>4.PreparedStatement接口</p>
<p>在实际开发中，如果涉及到向SQL语句传递参数，最好使用preparedStatement接口实现，不仅可以提高SQL的执行效率，而且还可以避免SQL的注入式攻击。</p>
<p>5.ResultSet接口</p>
<p>该接口位于java.sql包中，封装了数据查询的结果集。</p>
<h3 id="3-JDBC操作数据库"><a href="#3-JDBC操作数据库" class="headerlink" title="3.JDBC操作数据库"></a><em>3.JDBC操作数据库</em></h3><ul>
<li><p>添加数据</p>
</li>
<li><p>查询数据</p>
</li>
<li><p>修改数据</p>
</li>
<li><p>删除数据</p>
</li>
<li><p>批处理</p>
</li>
<li><p>调用存储过程</p>
<p>存储过程是一个SQL语句和可选控制流语句的预编译集合。在jdbc API中提供了调用存储过程的方法，通过CallableStatement对象进行操作。其调用方法：</p>
<p>{call《procedure-name》[(《arg1》,《arg2》,…)]},其中arg1,arg2为存储过程中的参数。</p>
</li>
</ul>
<h3 id="4-JDBC在Java-Web中的应用"><a href="#4-JDBC在Java-Web中的应用" class="headerlink" title="4.JDBC在Java Web中的应用"></a><em>4.JDBC在Java Web中的应用</em></h3><p>1.开发模式</p>
<p>MVC：该理念将软件分成三层：模型层(JavaBean)，视图层(JSP页面)，控制层(Servlet)</p>
<p>2.分页查询</p>
<p>通过ResultSet的光标实现分页</p>
<p>通过数据库机制进行分页</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/过滤器和监听器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/过滤器和监听器/" itemprop="url">过滤器和监听器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T21:42:07+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Sevlet过滤器"><a href="#1-Sevlet过滤器" class="headerlink" title="1.Sevlet过滤器"></a><em>1.Sevlet过滤器</em></h3><h4 id="1-什么是过滤器"><a href="#1-什么是过滤器" class="headerlink" title="1.什么是过滤器"></a>1.什么是过滤器</h4><p>servlet过滤器与servlet十分相似，但它具有拦截客户端请求的功能。</p>
<p>过滤器实质上是在web应用服务器上的web应用组件，用于拦截客户端资源与目标资源的请求。</p>
<h4 id="2-过滤器核心对象"><a href="#2-过滤器核心对象" class="headerlink" title="2.过滤器核心对象"></a>2.过滤器核心对象</h4><p>过滤器对象放置在javax.servlet包中。</p>
<ul>
<li><p>FilterConfig《interface》</p>
<p>该接口由servlet容器实现，主要用于获取过滤器中的配置信息。</p>
</li>
<li><p>Filter《interface》  </p>
<p>每个过滤对象都要直接或间接地实现Filter接口，在filter中定义了三个方法，分别是init(),doFilter(),destroy()方法。</p>
</li>
<li><p>FilterChain《interface》</p>
<p>该接口仍然由servlet容器实现。</p>
</li>
</ul>
<h4 id="3-过滤器的创建与配置"><a href="#3-过滤器的创建与配置" class="headerlink" title="3.过滤器的创建与配置"></a>3.过滤器的创建与配置</h4><p><strong>创建：</strong></p>
<p>创建一个过滤器对象需要实现Javax.servlet,Filter接口，同时实现Filter接口的三个方法。init():用于对过滤器的初始化进行处理。destroy():过滤器的销毁方法。</p>
<p>doFilter():用于过滤处理的业务逻辑。</p>
<p><strong>配置：</strong></p>
<p>《!–过滤器的声明–》</p>
<p>《filter》</p>
<p>《filter-name》MyFilter《/filter-name》</p>
<p>《filter-class》com.lyq.MyFilter《/filter-class》</p>
<p>《/filter》</p>
<p>《!–过滤器映射–》</p>
<p>《filter-mapping》</p>
<p>《filter-name》MyFilter《/filter-name》</p>
<p>《url-pattern》/MyFilter《/url-pattern》</p>
<p>《/filter-mapping》</p>
<h3 id="2-servlet监听器"><a href="#2-servlet监听器" class="headerlink" title="2.servlet监听器"></a><em>2.servlet监听器</em></h3><h4 id="1-servlet监听器简介"><a href="#1-servlet监听器简介" class="headerlink" title="1.servlet监听器简介"></a>1.servlet监听器简介</h4><p>监听器的作用是监听web容器中的有效事件，因此它是由容器管理的。</p>
<h4 id="2-servlet监听器的原理"><a href="#2-servlet监听器的原理" class="headerlink" title="2.servlet监听器的原理"></a>2.servlet监听器的原理</h4><p>servlet监听器是当今web开发的重要组成部分，它是在servlet2.3规范中和servlet过滤器一起引入的，并且在servlet2.4规范中进行较大的改进，主要用来对web应用进行监听和控制的，极大增强了web应用处理能力。</p>
<h4 id="3-servlet上下文监听"><a href="#3-servlet上下文监听" class="headerlink" title="3.servlet上下文监听"></a>3.servlet上下文监听</h4><p>servlet上下文监听可以监听servletContext对象的创建，删除以及属性的添加，删除和修改操作，该监听器需要用到如下两个接口。</p>
<p><strong>ServletContextListener接口</strong></p>
<p>该接口存放在javax.servlet包中，主要实现ServletContext的创建和删除。该接口提供了两个方法，也被称为“web应用程序的生命周期方法”</p>
<p>(1).contextInitialized(ServletContextEvent event)方法：通知正在收听的对象，应用程序已经被加载及初始化。</p>
<p>(2).contextDestroy(ServletContextEvent event)方法：通知正在收听的对象，应用程序已经被载出，即关闭。</p>
<p><strong>ServletContextAttributeListener接口</strong></p>
<p>该接口主要存放在javax.servlet包中，主要实现监听ServletContext属性的挺假，删除和修改。ServletContextAttributeListener接口提供了三个方法。</p>
<p>(1).attributeAdded(ServletContextAttributeEvent event)方法：当有对象加入到Application的范围时，通知正在收听的对象。</p>
<p>(2).attributeReplace(ServletContextAttributeEvent event)方法：当在application的范围中有对象取代另一个对象时，通知正在收听的对象。</p>
<p>(3).attributeRemove(ServletContextAttributeEvent event)方法：当有对象从application范围中移除时，通知正在收听的对象。</p>
<p><strong>创建监听器</strong>：</p>
<p>要让web容器启动时通知自定义的监听器，需要在web.xml中使用《listener》元素来配置监听器类。</p>
<p>eg:</p>
<p>《listener》</p>
<p>《listener-class》com.listener.MyContentListener《/listener-class》</p>
<p>《/listener》</p>
<h4 id="4-HTTP会话监听"><a href="#4-HTTP会话监听" class="headerlink" title="4.HTTP会话监听"></a>4.HTTP会话监听</h4><p>HTTP会话监听信息，有四个接口可以进行监听。</p>
<ul>
<li><p>HttpSessionListener接口</p>
<p>该接口实现HTTP会话的创建和销毁。该接口提供了以下两个方法：</p>
<p>(1).sessionCreated(HttpSessionEvent event)方法：通知正在收听的对象，session已经被加载及初始化。</p>
<p>(2).sessionDestroyed(HttpSessionEvent event)方法：通知正在收听的对象，session已经被载出。</p>
</li>
<li><p>HttpSessionActivationListener接口</p>
</li>
<li><p>该接口实现监听HTTP会话active和passivate。该接口提供了三个方法：</p>
<p>(1).attributeAdded(HttpSessionBindingEvent event)方法：当有对象加入到session的范围时，通知正在收听的对象。</p>
<p>(2).attributeReplaced(HttpSessionBindingEvent event)方法：当在session范围内有对象取代另一个对象时，通知正在收听的对象。</p>
<p>(3).attributeRemove(HttpSessionBindingEvent event)方法：当有对象从session范围在移除时，通知正在收听的对象。</p>
</li>
<li><p>HttpBindingListener接口</p>
<p>HttpBindingListener接口实现监听HTTP会话中对象的绑定信息。它是唯一不需要在web.xml中设定Listener的。该接口提供了以下两个方法。</p>
<p>(1).valueBound(HttpSessionBindingEvent event)方法：当有对象加入到session范围时会被自动调用。</p>
<p>(2).valueUnBound(HttpSessionBindingEvent event)方法：当有对象从session范围内移除时会被自动调用。</p>
</li>
<li><p>HttpSessionAttributeListener接口</p>
<p>该接口实现监听HTTP会话中属性的设置请求。</p>
<p>(1).sessionDidActivate(HttpSessionEvent event)方法：通知正在收听的对象，他的session已经变为有效状态。</p>
<p>(2).sessionWillPassivate(HttpSession event)方法：通知正在收听的对象，他的session已经变为无效状态。</p>
</li>
</ul>
<h4 id="5-servlet请求监听"><a href="#5-servlet请求监听" class="headerlink" title="5.servlet请求监听"></a>5.servlet请求监听</h4><ul>
<li><p>SevletRequestListener接口</p>
<p>该接口提供了以下两个方法：</p>
<p>(1).requestInitalized(ServletRequestEvent event)方法:通知正在收听的对象，ServletRequest已经被加载及初始化。</p>
<p>(2).requestDestroyed(ServletRequestEvent event)方法：通知正在收听的对象，ServletRequest对象已经被载出，即关闭。</p>
</li>
<li><p>ServletRequestAttributeListener接口</p>
<p>该接口提供了以下三个方法：</p>
<p>(1).attributeAdded(ServletRequestAttributeEvent event)方法：当有对象加入到request的范围时，通知正在收听的对象。</p>
<p>(2).attributeReplaced(ServletRequestAttributeEvent event)方法：当在request范围内有对象取代另一个对象时，通知正在收听的对象。</p>
<p>(3).attributeRemove(ServletRequestAttributeEvent event)方法：当有对象从request范围在移除时，通知正在收听的对象。</p>
</li>
</ul>
<h3 id="3-servlet3-0的新特性"><a href="#3-servlet3-0的新特性" class="headerlink" title="3.servlet3.0的新特性"></a><em>3.servlet3.0的新特性</em></h3><p>1.新增注释</p>
<ul>
<li><p>@WebServlet</p>
<p>eg:@WebServlet(name=”saveSErvlet” urlPatterns=”/SaveServlet”)</p>
</li>
<li><p>@WebFilter</p>
<p>eg:@WebFilter(filterName=”char”,urlPatterns=”/*”)</p>
</li>
<li><p>@WebListener</p>
<p>eg:@WebListener(“This is only a demo listener”)</p>
</li>
<li><p>@WebInitParam</p>
<p>eg:@WebServlet(urlPatterns=”/simple”,name=”SimpleServlet”,</p>
<p>initParam={@WebInitParam(name=”username”,value=”tom”)})</p>
</li>
</ul>
<p>2.对文件上传的支持</p>
<p>实现文件上传需要实现两件事：</p>
<p>需要添加@MultipartConfig注释</p>
<p>从request对象中获取Part文件对象</p>
<p>3.异步处理</p>
<p>在servlet3.0之前,一个servlet的工作流程是：首先，servlet接收到请求后，需要对请求携带的数据进行一些预处理。接着调用业务接口的某些方法，以完成业务处理。最后，根据处理的结果提交响应。</p>
<p>现在通过servlet3.0的异步处理机制可以将处理流程调整为以下流程：首先，servlet接收到请求后，需要对请求携带的数据进行一些预处理。接着servlet线程将请求转交给异步线程来执行业务处理，线程本身返回至容器。</p>
<p>这样，Servlet线程不在一直处于阻塞状态以等待业务逻辑的处理，而是启动异步后可以立即返回。</p>
<p>异步处理机制可应用于servlet和过滤器两种组件。@WebServlet和@WebFilter注释提供了asyncSupported属性，默认该属性的取值为false,要启动异步处理支持，只需将属性设置为true即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/Servlet技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/Servlet技术/" itemprop="url">Servlet技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T11:02:21+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-servlet基础"><a href="#1-servlet基础" class="headerlink" title="1.servlet基础"></a><em>1.servlet基础</em></h2><p>servlet是运行在web服务器端的Java应用程序。</p>
<h4 id="1-servlet的体系结构"><a href="#1-servlet的体系结构" class="headerlink" title="1.servlet的体系结构"></a>1.servlet的体系结构</h4><p>servlet 《interface》  servletConfig《interface》 serializable《interface》</p>
<p>​                                    GenericServlet&lt;抽象类&gt;</p>
<p>​                                        HttpServlet</p>
<h4 id="2-servlet技术特点"><a href="#2-servlet技术特点" class="headerlink" title="2.servlet技术特点"></a>2.servlet技术特点</h4><ul>
<li><p>功能强大</p>
<p>由于servlet拥有Java提供的API,而且还可以调用servlet分装的servletAPI编程接口。</p>
</li>
<li><p>可移植性</p>
<p>servlet继承了Java语言的优点，程序一次编码，多平台运行，拥有超强的可移植性。</p>
</li>
<li><p>性能高效</p>
<p>servlet对象在servlet容器启动时被初始化，当第一次被请求时，servlet容器将其实例化，此时它贮存于内存中，如果存在多个请求，servlet不会再实例化。因此，    servlet对请求处理的性能是十分高效的。</p>
</li>
<li><p>安全性能高</p>
<p>servlet使用了Java的安全框架，同时servlet容器还可以为servlet提供额外的功能，他的安全性能是非常高的。</p>
</li>
<li><p>可扩展</p>
<p>servlet继承了Java的面向对象的优点，在业务处理中，可以通过封装，继承等来扩展实际的业务需要，其扩展性非常强。</p>
</li>
</ul>
<h4 id="3-servlet与JSP的区别"><a href="#3-servlet与JSP的区别" class="headerlink" title="3.servlet与JSP的区别"></a>3.servlet与JSP的区别</h4><p>1.角色不同</p>
<p>JSP页面存在HTML与Java代码并存的情况，而servlet需要承担客户请求与业务处理的中间角色，只有调用固定的方法才能将动态内容输出为静态的HTML。</p>
<p>2.编程方法不同</p>
<p>servlet开发需要遵从Java的标准，而JSP需要遵循一定的脚本语言规范。在servlet代码中，需要调用servlet提供的相关API接口方法，才可以对HTTP请求及业务进行处理。而JSP页面通过HTML代码与内置对象实现对HTTP请求及页面的处理。</p>
<p>3.servlet需要编译后运行</p>
<p>servlet需要在Java编译器编译后才能运行。而JSP由JSP Container对其进行管理，他的编辑过程也由JSP Container对JSP进行自动编辑。</p>
<p>4.速度不同</p>
<p>由于JSP Container在每次执行不同内容的动态JSP页面时都需对其自动编译，所以效率低于servlet的执行效率。</p>
<h4 id="4-servlet的代码结构"><a href="#4-servlet的代码结构" class="headerlink" title="4.servlet的代码结构"></a>4.servlet的代码结构</h4><p>通常所说的servlet是指httpservlet对象。</p>
<p>该类中包含六个方法，其中init()与destroy()方法为servlet初始化与生命周期结束所调用的方法，其余的四个方法为servlet针对不同的HTTP请求所提供的方法。（doGet(),doPost(),doPut(),doDelete()）</p>
<h2 id="2-servlet-API-编程常用接口和类"><a href="#2-servlet-API-编程常用接口和类" class="headerlink" title="2.servlet API 编程常用接口和类"></a><em>2.servlet API 编程常用接口和类</em></h2><p>1.servlet接口</p>
<p>2.servletConfig接口</p>
<p>3.HttpServletRequest接口</p>
<p>4.HttpServletResonse接口</p>
<p>5.GenericServlet类</p>
<p>6.HttpServlet类</p>
<h2 id="3-servlet开发"><a href="#3-servlet开发" class="headerlink" title="3.servlet开发"></a><em>3.servlet开发</em></h2><p>1.servlet创建</p>
<p>第一种方法：创建一个普通的Java类，使这个类继承HttpServlet类，再手动配置web.xml文件注册Servlet对象。</p>
<p>第二种方法：直接通过IDE集成开发工具进行创建。</p>
<p>2.servlet配置</p>
<p>(1)声明servlet对象</p>
<p>在web.xml中的声明语句如下：</p>
<p>《servlet》</p>
<p>《servlet-name》SimpleServlet《/servlet-name》</p>
<p>《servlet-class》com.lyq.SimpleServlet《/servlet-class》</p>
<p>《/servlet》</p>
<p>(2)映射servlet</p>
<p>在web.xml声明后，需要映射访问servlet的URL。</p>
<p>其配置方法如下：</p>
<p>《servlet-mapping&gt;</p>
<p>​     《servlet-name》SimpleServlet《/servlet-name》</p>
<p>​     《url-pattern》SimpleServlet《/url-patterns》</p>
<p>《/servlet-mapping》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/03/JavaBean技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/03/JavaBean技术/" itemprop="url">JavaBean技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-03T10:41:25+08:00">
                2018-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-javaBean概述"><a href="#1-javaBean概述" class="headerlink" title="1.javaBean概述"></a><em>1.javaBean概述</em></h4><p>这种与HTML相分离，而使用Java代码封装的类，就是一个JavaBean组件。</p>
<h4 id="2-JavaBean种类"><a href="#2-JavaBean种类" class="headerlink" title="2.JavaBean种类"></a><em>2.JavaBean种类</em></h4><p>可视化的JavaBean：用来实现可视化界面，如窗体，按钮，文本框等。</p>
<p>非可视化的JavaBean：用于实现业务逻辑或封装业务对象。</p>
<h4 id="3-JavaBean的应用"><a href="#3-JavaBean的应用" class="headerlink" title="3.JavaBean的应用"></a><em>3.JavaBean的应用</em></h4><p>1.获取JavaBean的属性信息</p>
<p>eg：&lt;jsp:useBean id=”produce” class=”com.lyq.bean.Produce”&gt;&lt;/jsp:useBean &gt;</p>
<p>&lt;jsp:getProperty property=”name” name=”produce”&gt;</p>
<p>2.对JavaBean的属性赋值</p>
<p>eg：&lt;jsp:useBean id=”produce” class=”com.lyq.bean.Produce”&gt;&lt;/jsp:useBean &gt;</p>
<p>&lt;jsp:setProperty property=”name” name=”produce” value=”洗衣机”&gt;</p>
<p>3.如何在JSP中应用JavaBean</p>
<p>JavaBean的生命周期可以自行设定，它存在于四中=种范围内，分别为page，request，session和application。默认情况下，JavaBean作用在page范围内。</p>
<p>eg：&lt;jsp:useBean id=”produce” class=”com.lyq.bean.Produce” scope=”page”&gt;&lt;/jsp:useBean &gt;</p>
<p>&lt;jsp:setProperty property=”*” name=”produce” &gt;//用于接收表单中的信息</p>
<p>&lt;jsp:getProperty property=”name” name=”produce”&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/31/JSP内置对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/31/JSP内置对象/" itemprop="url">JSP内置对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-31T21:38:55+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-JSP内置对象"><a href="#1-JSP内置对象" class="headerlink" title="1.JSP内置对象"></a><em>1.JSP内置对象</em></h4><p>JSP提供了由容器实现和管理的内置对象，也可以称之为隐含对象。这些对象不需要通过JSP页面编写来实例化，在所有的JSP页面中都可以直接使用，它起到了简化页面的作用。在JSP中一共预定义了9个这样的对象。分别为：request，response，session，application，out，page，pageContext,config,exception。</p>
<h4 id="2-request对象"><a href="#2-request对象" class="headerlink" title="2.request对象"></a><em>2.request对象</em></h4><p>request对象封装了由客户端生成的http请求的所有细节，包含http头信息，系统信息，请求方式，请求参数等。</p>
<ul>
<li><p>访问请求参数</p>
<p>在使用request的getParameter()方法获取传递的参数值时，如果指定的参数不存在，将返回null；如果指定了参数名，但未指定参数值，则返回“‘。</p>
</li>
<li><p>在作用域中管理属性</p>
<p>在进行请求转发时，需要把一些数据传递到转发后的页面进行处理。这时就需要使用request对象的setAttribute()方法将数据保存到request范围内的变量中。</p>
<p>request.setAttribute(String name,Object obj);</p>
<p>将数据保存到request范围内的变量中，可以通过request对象的getAttribute()的方法获取该变量的值。</p>
<p>request.getAttribute(String name);</p>
</li>
<li><p>获取cookie</p>
<p>cookie是小段的文本信息，在网络服务器上生成，并发送给浏览器，通过使用cookie可以标识用户身份，记录用户名和密码，跟踪重复用户等。浏览器将cookie以key/value的形式保存到客户机的某个指定目录中。</p>
<p>cookie的getCookies()方法可获取所有对象的集合；通过cookie对象的getName()可获取指定名称的cookie;通过getValue可获得cookie对象的值。另外将一个cookie对象发送到客户端，使用request的addCookie()方法。</p>
</li>
<li><p>解决中文乱码</p>
<p>为了解决请求参数的文字编码方式（一般都是ISO-8859-1）与页面的编码方式（UTF-8)不一致所造成的乱码。只要将获取到的数据通过String的构造方法使用指定的编码类型重新构造一个String对象，即可正确的显示出中文信息。</p>
<p>eg:&lt;%=new String(request.getParamater(“name”).getBytes(“ISO-8859-1”),”UTF-8”)%&gt;</p>
</li>
<li><p>获取客户端信息</p>
<p>getHeader(String name)     获取HTTP协议定义的文件头信息</p>
<p>getHeaders(String name)    返回指定名字的request Header的所有值，其结果是一个枚举型的实例</p>
<p>getHeadersName()    返回所有request Header的名字，其结果是一个枚举型的实例</p>
<p>getMethod()   获取客户端向服务端传送数据的方法，如get,post,header,trace等</p>
<p>getProtocol   获取客户端向服务器传送数据所依据的协议的名称</p>
<p>getRequestURI()  获取发出请求字符串的客户端地址，不包括请求参数</p>
<p>getRequestURL()  获取发出请求字符串的客户端地址</p>
<p>getRealPath()  返回当前请求文件的绝对路径</p>
<p>getRemoteAddr()  获取客户端的IP地址</p>
<p>getRemoteHost()  获取客户端的主机名</p>
<p>getServerName()  获取服务器的名字</p>
<p>getServerPath()   获取客户端所请求的脚本文件的文件路径</p>
<p>getServerPort()  获取服务器的端口号</p>
</li>
<li><p>显示国际化信息</p>
<p>浏览器可以通过accept-language的HTTP报头向web服务器指明它所使用的本地语言。request对象中的getLocale()和getLocales()方法允许JSP开发人员获取这一信息，获取的信息属于java.util.Local类型。</p>
</li>
</ul>
<h4 id="3-response对象"><a href="#3-response对象" class="headerlink" title="3.response对象"></a><em>3.response对象</em></h4><p>response对象用于响应客户请求，向客户端输出信息。它封装了JSP产生的响应，并发送到客户端以响应客户端的请求。</p>
<ul>
<li><p>重定向网页</p>
<p>response.sendRedirect(String url);</p>
</li>
<li><p>处理HTTP文件头</p>
<p>禁用缓存</p>
<p>eg:&lt;%</p>
<p>response.setHeader(“Cache-Control”,”no-store”);</p>
<p>response.setDateHeader(“Expires”,0);</p>
<p>%&gt;</p>
<p>设置页面自动刷新</p>
<p>eg:&lt;%</p>
<p>response.setHeader(“refresh”,”10”);</p>
<p>%&gt;</p>
<p>定时跳转页面</p>
<p>eg:&lt;%</p>
<p>response.setHeader(“refresh”,”5;URL=login.jsp”);</p>
<p>%&gt;</p>
</li>
<li><p>设置输出缓冲</p>
<p>当满足以下三种情形之一，就会把缓冲区的内容写到客户端。</p>
<p>JSP页面的输出信息已经全部写到缓冲区</p>
<p>缓冲区已满</p>
<p>在JSP页面中，调用了response对象的flushBuffer()方法或out对象的flush()方法</p>
</li>
</ul>
<h4 id="4-session对象"><a href="#4-session对象" class="headerlink" title="4.session对象"></a><em>4.session对象</em></h4><p>session在网络中被称为会话。通过session可以在应用程序的web页面间进行跳转时，保存用户的状态，使整个用户会话一直存在下去，直到关闭浏览器。</p>
<ul>
<li><p>创建及获取客户的会话</p>
<p>通过session对象可以读取或存储客户相关信息。</p>
<p>session.setAttribute(String name,Object obj)</p>
<p>session.getAttribute(String name)</p>
</li>
<li><p>从会话中移动指定的绑定对象</p>
<p>若想要移除存储在session中的对象</p>
<p>session.removeAtribute(String name)</p>
</li>
<li><p>销毁session</p>
<p>sesssion.invalidate();</p>
</li>
<li><p>会话超时的管理</p>
<p>session.getLastAccessedTime():返回客户端最后一次与会话相关的请求时间。</p>
<p>session.setMaxInactiveInterval():以秒为单位返回一个会话内两个请求最大时间间隔。</p>
<p>session.setMaxInactiveInterval():以秒为单位设置session的有效时间。</p>
</li>
<li><p>session对象的应用</p>
<p>session是较常用的内置对象之一，与request对象相比其作用范围更大。</p>
</li>
</ul>
<h4 id="5-application对象"><a href="#5-application对象" class="headerlink" title="5.application对象"></a><em>5.application对象</em></h4><p>application对象用于保存所有应用程序中的公有数据。它在服务器启动时自动创建，在服务器停止时销毁。</p>
<ul>
<li><p>访问应用程序初始化参数</p>
<p>应用程序初始化参数在web.xml文件中进行设置。</p>
<p>application.getInitparameter(String name);</p>
</li>
<li><p>管理应用程序环境属性</p>
<p>getAttributeName():获取所有application对象使用的属性名</p>
<p>getAttribute(String name)：从application对象中获取指定的对象名</p>
<p>setAttribute(String key,Object obj):使用指定名称和指定对象在application对象中进行关联</p>
<p>removeAtrribute(String name)：从application对象中去掉指定名称的属性</p>
</li>
</ul>
<h4 id="6-out对象"><a href="#6-out对象" class="headerlink" title="6.out对象"></a><em>6.out对象</em></h4><p>out对象用于在web浏览器内输出信息，并且管理应用服务器上的输出缓冲器。</p>
<ul>
<li><p>向客户端输出数据</p>
<p>print()方法用于向客户浏览器输出信息</p>
</li>
<li><p>管理响应缓冲</p>
<p>clear()清除缓冲区中的内容</p>
<p>clearBuffer()清除当前缓冲区的内容</p>
<p>flush()刷新流</p>
<p>isAutoFlush()检测当前缓冲区已满时是自动清空，还是抛出异常</p>
<p>getBufferSize()获取缓冲区的大小</p>
</li>
</ul>
<h4 id="7-其它内置对象"><a href="#7-其它内置对象" class="headerlink" title="7.其它内置对象"></a><em>7.其它内置对象</em></h4><ul>
<li>获取会话的pageContext对象</li>
<li>读取web.xml配置信息的config对象</li>
<li>应答或请求的page对象</li>
<li>获取异常信息的exception对象</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/29/了解JSP页面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/了解JSP页面/" itemprop="url">JSP基本语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T21:18:18+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-了解JSP页面"><a href="#1-了解JSP页面" class="headerlink" title="1.了解JSP页面"></a><em>1.了解JSP页面</em></h4><p>在一个JSP页面中，可以包括指令标识，HTML代码，JavaScript代码，嵌入的Java代码，注释和JSP动作标识等内容。</p>
<h4 id="2-指令标识"><a href="#2-指令标识" class="headerlink" title="2.指令标识"></a><em>2.指令标识</em></h4><h6 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h6><p>指令标识主要用于设定整个JSP页面范围内都有效的相关信息，它是被服务器解释执行的，不会产生任何内容输出到网页中。</p>
<h6 id="2-语法格式："><a href="#2-语法格式：" class="headerlink" title="2.语法格式："></a>2.语法格式：</h6><p>&lt;%@ 指令名 属性1=“属性值1” 属性2=“属性值2”……%&gt;</p>
<p>指令名：在JSP中包含page，include和taglib三条指令</p>
<ul>
<li><p>page指令</p>
<p>language属性：</p>
<p>用于设置JSP页面使用的语言，目前只支持Java。</p>
<p>extends属性：</p>
<p>用于设置JSP页面继承的Java类。</p>
<p>pageEncoding属性：</p>
<p>用于设置JSP页面的编码格式。</p>
<p>contentType属性：</p>
<p>用于设置JSP页面的MIME类型和字符编码。</p>
<p>session属性：</p>
<p>用于设置JSP页面是否使用HTTP的session会话对象。属性值是布尔型。</p>
<p>buffer属性：</p>
<p>用于设置JSP的out输出对象使用的缓冲区大小，默认为8kb，单位只能用kb。</p>
<p>import属性：</p>
<p>用于设置JSP页面导入的类包。</p>
<p>autoFlush属性：</p>
<p>用于设置JSP页面缓存满时，是否刷新缓存。默认为true。</p>
<p>isErrorPage属性：</p>
<p>可以将当前的JSP页面设置成错误处理页面来处理另一个JSP页面的错误，也就是异常处理。</p>
<p>errorPage属性：</p>
<p>用来指定处理当前JSP页面异常错误的另一个JSP页面。</p>
</li>
<li><p>include指令</p>
<p>通过该指令可以在一个JSP页面中包含另一个JSP页面。不过该指令是静态包含，即被包含文件中的所有内容会被原样包含到该JSP页面中。</p>
<p>语法格式:&lt;%@ include file=”path”%&gt;</p>
<p>只有file一个属性，用于指定包含文件的路径，该路径可以是相对路径，也可以是绝对路径。</p>
</li>
<li><p>taglib指令</p>
<p>通过该指令声明该页面中所使用的标签库，同事引用标签库，并指定标签的前缀。</p>
<p>语法格式：&lt;%@ taglib prefix=”c” uri=””%&gt;</p>
<p>prefix:用于指定标签的前缀。</p>
<p>uri:用于指定标签文件的存放位置。</p>
</li>
</ul>
<h4 id="3-脚本标识"><a href="#3-脚本标识" class="headerlink" title="3.脚本标识"></a><em>3.脚本标识</em></h4><h6 id="1-JSP表达式"><a href="#1-JSP表达式" class="headerlink" title="1.JSP表达式"></a>1.JSP表达式</h6><p>用于向页面中输出信息</p>
<p>语法格式：&lt;%= 表达式%&gt;</p>
<h6 id="2-声明标识"><a href="#2-声明标识" class="headerlink" title="2.声明标识"></a>2.声明标识</h6><p>用于在JSP页面中定义全局的变量和方法。</p>
<p>语法格式：&lt;%! 声明变量或方法的代码%&gt;</p>
<h6 id="3-代码片段"><a href="#3-代码片段" class="headerlink" title="3.代码片段"></a>3.代码片段</h6><p>就是在JSP页面中嵌入的Java代码或脚本代码。</p>
<p>语法格式：&lt;% Java代码或是脚本代码%&gt;</p>
<h4 id="4-JSP注释"><a href="#4-JSP注释" class="headerlink" title="4.JSP注释"></a><em>4.JSP注释</em></h4><h6 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1.单行注释"></a>1.单行注释</h6><p>//注释内容</p>
<h6 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2.多行注释"></a>2.多行注释</h6><p>/*</p>
<p>注释内容1</p>
<p>注释内容2</p>
<p>*/</p>
<p>或</p>
<p>/*</p>
<p> *注释内容1</p>
<p> *注释内容2</p>
<p>*/</p>
<h6 id="3-提示文档注释"><a href="#3-提示文档注释" class="headerlink" title="3.提示文档注释"></a>3.提示文档注释</h6><p>/**</p>
<p>提示信息1</p>
<p>提示信息2</p>
<p>*/</p>
<p>或</p>
<p>/**</p>
<p> *提示信息1</p>
<p> *提示信息2</p>
<p>*/</p>
<h6 id="4-隐藏注释"><a href="#4-隐藏注释" class="headerlink" title="4.隐藏注释"></a>4.隐藏注释</h6><p>这种注释不仅在浏览器中看不到，而且在HTML源代码中也看不到。</p>
<p>&lt;%- 注释内容 -%&gt;</p>
<h6 id="5-动态注释"><a href="#5-动态注释" class="headerlink" title="5.动态注释"></a>5.动态注释</h6><p>由于HTML注释对JSP嵌入的代码不起作用，因此可以利用他们的组合构成动态的HTML注释文本。</p>
<p>&lt;!– &lt;%=new Date()%&gt; -－&gt;</p>
<h4 id="5-动作标示"><a href="#5-动作标示" class="headerlink" title="5.动作标示"></a><em>5.动作标示</em></h4><h6 id="1-包含文件标识-lt-jsp-include-gt"><a href="#1-包含文件标识-lt-jsp-include-gt" class="headerlink" title="1.包含文件标识&lt;jsp:include &gt;"></a>1.包含文件标识&lt;jsp:include &gt;</h6><p>语法格式：&lt;jsp:include page=”url” flush=”fasle|true”/&gt;</p>
<p>或&lt;jsp:include page=”url” flush=”false|true”&gt;子动作标示&lt;jsp:param &gt;&lt;/jsp:include &gt;</p>
<p>page：用于指定被包含文件的相对路径</p>
<p>flush：可选属性，用于是否刷新缓冲区</p>
<p>子动作标示&lt;jsp:param &gt;：用于向被包含的动态页面中传递参数</p>
<p><strong>include指令与&lt;jsp:include &gt;动作标识的区别：</strong></p>
<ul>
<li>include指令的file属性不支持任何表达式。而&lt;jsp:include &gt;的page属性支持JSP表达式。</li>
<li>使用include指令时，被包含的文件内容会原封不动地插入到包含页中，然后JSP编译器再将合成的文件编译成一个Java文件。而使用&lt;jsp:include &gt;包含文件时，当标示被执行时，程序会将请求转发到被包含的页面，并将执行结果输出到浏览器，然后返回包含页继续执行后面的代码。</li>
<li>使用include指令包含文件，由于被包含的文件终会生成一个文件，所以在被包含文件，包含文件中不能有重名的变量和方法。而&lt;jsp:include &gt;包含文件时，是单独编译的，所以重名的变量和方法是不冲突的。</li>
</ul>
<h6 id="2-请求转发标识-lt-jsp-forward-gt"><a href="#2-请求转发标识-lt-jsp-forward-gt" class="headerlink" title="2.请求转发标识&lt;jsp:forward &gt;"></a>2.请求转发标识&lt;jsp:forward &gt;</h6><p>语法：&lt;jsp:forward page=”url” &gt;或</p>
<p>&lt;jsp:forward page=”url”&gt;</p>
<p>子动作标识&lt;jsp:param &gt;</p>
<p>&lt;/jsp:forward &gt;</p>
<h6 id="3-传递参数标识-lt-jsp-param-gt"><a href="#3-传递参数标识-lt-jsp-param-gt" class="headerlink" title="3.传递参数标识&lt;jsp:param &gt;"></a>3.传递参数标识&lt;jsp:param &gt;</h6><p>语法：&lt;jsp:param name=”参数名” value=”参数值”&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/27/算法总结（七）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="佩琪">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小猪佩琪">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/算法总结（七）/" itemprop="url">算法总结（七）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-27T09:41:45+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1-序列化二叉树"><a href="#1-序列化二叉树" class="headerlink" title="1.序列化二叉树"></a>1.序列化二叉树</h4><p>请实现两个函数，分别用来序列化和反序列化二叉树</p>
<blockquote>
<p>分析:根据前序遍历规则完成序列化与反序列化。所谓序列化指的是遍历二叉树为字符串；所谓反序列化指的是依据字符串重新构造成二叉树。</p>
<p>依据前序遍历序列来序列化二叉树，因为前序遍历序列是从根结点开始的。当在遍历二叉树时碰到Null指针时，这些Null指针被序列化为一个特殊的字符“#”。</p>
<p>另外，结点之间的数值用逗号隔开.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">  int index=-1;</span><br><span class="line">	String Serialize(TreeNode root) &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		if (root == null) &#123;</span><br><span class="line">			sb.append(&quot;#,&quot;);</span><br><span class="line">			return sb.toString();</span><br><span class="line">		&#125;</span><br><span class="line">		sb.append(root.val+&quot;,&quot;);</span><br><span class="line">		sb.append(Serialize(root.left));</span><br><span class="line">		sb.append(Serialize(root.right));</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	TreeNode Deserialize(String str) &#123;</span><br><span class="line">     String []s=str.split(&quot;,&quot;);</span><br><span class="line">     index++;</span><br><span class="line">     TreeNode node=null;</span><br><span class="line">     if(!s[index].equals(&quot;#&quot;)) &#123;</span><br><span class="line">    	 node=new TreeNode(Integer.valueOf(s[index]));</span><br><span class="line">    	 node.left=Deserialize(str);</span><br><span class="line">    	 node.right=Deserialize(str);</span><br><span class="line">     &#125;</span><br><span class="line">     return node;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-二叉搜索树的第k个结点"><a href="#2-二叉搜索树的第k个结点" class="headerlink" title="2.二叉搜索树的第k个结点"></a>2.二叉搜索树的第k个结点</h4><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p>
<blockquote>
<p>分析：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。</p>
<p>  所以，按照中序遍历顺序找到第k个结点就是结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   int index = 0; //计数器</span><br><span class="line">    TreeNode KthNode(TreeNode root, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        if(root != null)&#123; //中序遍历寻找第k个</span><br><span class="line">            TreeNode node = KthNode(root.left,k);</span><br><span class="line">            if(node != null)</span><br><span class="line">                return node;</span><br><span class="line">            index ++;</span><br><span class="line">            if(index == k)</span><br><span class="line">                return root;</span><br><span class="line">            node = KthNode(root.right,k);</span><br><span class="line">            if(node != null)</span><br><span class="line">                return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-数据流中的中位数"><a href="#3-数据流中的中位数" class="headerlink" title="3.数据流中的中位数"></a>3.数据流中的中位数</h4><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p>
<blockquote>
<p>分析：利用两个PriorityQueue优先队列，一个栈A采用默认第一个是最小值，另一个栈B重写比较方法改为第一个是最大值。通过出入栈控制B中的数量大于栈A1个或0个。根据一共入栈的数量的奇偶数，分别计算出中位数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">   PriorityQueue&lt;Integer&gt; q2 = new PriorityQueue&lt;&gt;();</span><br><span class="line">	PriorityQueue&lt;Integer&gt; q1 = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">			// TODO Auto-generated method stub</span><br><span class="line">			return o2 - o1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	public void Insert(Integer num) &#123;</span><br><span class="line">    if(q1.isEmpty()||num&lt;=q1.peek()) &#123;</span><br><span class="line">    	q1.add(num);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">    	q2.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    if(q1.size()+1==q2.size()) &#123;</span><br><span class="line">    	q1.add(q2.poll());</span><br><span class="line">    &#125;</span><br><span class="line">    if(q1.size()==q2.size()+2) &#123;</span><br><span class="line">    	q2.add(q1.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Double GetMedian() &#123;</span><br><span class="line">        System.out.println(&quot;队列１&quot;+q1);</span><br><span class="line">		System.out.println(&quot;队列2&quot;+q2);</span><br><span class="line">       if(q1.size()==q2.size()) &#123;</span><br><span class="line">    	   return (q1.peek()+q2.peek())/2.0;</span><br><span class="line">       &#125;</span><br><span class="line">       else &#123;</span><br><span class="line">    	   return  Double.valueOf(q1.peek())  ;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">佩琪</p>
              <p class="site-description motion-element" itemprop="description">JAVA</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">佩琪</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
